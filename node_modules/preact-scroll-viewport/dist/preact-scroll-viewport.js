!function(global, factory) {
    "object" == typeof exports && "undefined" != typeof module ? module.exports = factory(require("preact")) : "function" == typeof define && define.amd ? define([ "preact" ], factory) : global.ScrollViewport = factory(global.preact);
}(this, function(preact) {
    function _objectWithoutProperties(obj, keys) {
        var target = {};
        for (var i in obj) keys.indexOf(i) >= 0 || Object.prototype.hasOwnProperty.call(obj, i) && (target[i] = obj[i]);
        return target;
    }
    function _possibleConstructorReturn(self, call) {
        if (self) return !call || "object" != typeof call && "function" != typeof call ? self : call;
    }
    function _inherits(subClass, superClass) {
        "function" != typeof superClass && null !== superClass || (subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: !1,
                writable: !0,
                configurable: !0
            }
        }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass));
    }
    var EVENT_OPTS = {
        passive: !0,
        capture: !0
    };
    return function(_Component) {
        function ScrollViewport() {
            for (var _temp, _this, _ret, _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return _temp = _this = _possibleConstructorReturn(this, _Component.call.apply(_Component, [ this ].concat(args))), 
            _this.resized = function() {
                var height = window.innerHeight || document.documentElement.offsetHeight;
                height !== _this.state.height && _this.setState({
                    height: height
                });
            }, _this.scrolled = function() {
                var offset = Math.max(0, _this.base && -_this.base.getBoundingClientRect().top || 0);
                _this.setState({
                    offset: offset
                }), _this.props.sync && _this.forceUpdate();
            }, _ret = _temp, _possibleConstructorReturn(_this, _ret);
        }
        return _inherits(ScrollViewport, _Component), ScrollViewport.prototype.computeRowHeight = function() {
            if (this._height) return this._height;
            var first = this.base && this.base.firstElementChild && this.base.firstElementChild.firstElementChild;
            return this._height = first && first.offsetHeight || 0;
        }, ScrollViewport.prototype.componentDidUpdate = function() {
            this.resized();
        }, ScrollViewport.prototype.componentDidMount = function() {
            this.resized(), this.scrolled(), addEventListener("resize", this.resized, EVENT_OPTS), 
            addEventListener("scroll", this.scrolled, EVENT_OPTS);
        }, ScrollViewport.prototype.componentWillUnmount = function() {
            removeEventListener("resize", this.resized, EVENT_OPTS), removeEventListener("scroll", this.scrolled, EVENT_OPTS);
        }, ScrollViewport.prototype.render = function(_ref, _ref2) {
            var _ref2$offset = _ref2.offset, offset = void 0 === _ref2$offset ? 0 : _ref2$offset, _ref2$height = _ref2.height, height = void 0 === _ref2$height ? 0 : _ref2$height, _ref$overscan = _ref.overscan, overscan = void 0 === _ref$overscan ? 10 : _ref$overscan, rowHeight = _ref.rowHeight, defaultRowHeight = _ref.defaultRowHeight, children = _ref.children, props = _objectWithoutProperties(_ref, [ "overscan", "rowHeight", "defaultRowHeight", "children" ]);
            rowHeight = rowHeight || this.computeRowHeight() || defaultRowHeight || 100;
            var estimatedHeight = rowHeight * children.length;
            "string" == typeof props.style ? props.style += " height:" + estimatedHeight + "px;" : (props.style || (props.style = {})).height = estimatedHeight.toExponential() + "px";
            var start = 0, visibleRowCount = 1;
            rowHeight && (start = offset / rowHeight | 0, visibleRowCount = height / rowHeight | 0, 
            overscan && (start = Math.max(0, start - start % overscan), visibleRowCount += overscan));
            var end = start + 1 + visibleRowCount, visible = children.slice(start, end);
            return preact.h("div", props, preact.h("div", {
                style: {
                    position: "relative",
                    top: start * rowHeight
                }
            }, visible));
        }, ScrollViewport;
    }(preact.Component);
});
//# sourceMappingURL=preact-scroll-viewport.js.map