"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useAccount = void 0;
const react_1 = require("react");
const hooks_1 = require("../hooks");
/**
 * Generic hook to get a cached, auto updating, deserialized form of any Solana account. Massively saves on RPC usage by using
 * the spl-utils accountFetchCache.
 *
 * @param key
 * @param parser
 * @param isStatic
 * @returns
 */
function useAccount(key, parser, isStatic = false // Set if the accounts data will never change, optimisation to lower websocket usage.
) {
    const cache = (0, hooks_1.useAccountFetchCache)();
    const [state, setState] = (0, react_1.useState)({
        loading: true,
    });
    const parsedAccountBaseParser = (pubkey, data) => {
        try {
            const info = parser(pubkey, data);
            return {
                pubkey,
                account: data,
                info,
            };
        }
        catch (e) {
            console.error("Error while parsing", e);
            return {
                pubkey,
                account: data,
                info: undefined
            };
        }
    };
    const id = typeof key === "string" ? key : key === null || key === void 0 ? void 0 : key.toBase58();
    (0, react_1.useEffect)(() => {
        // Occassionally, dispose can get called while the cache promise is still going.
        // In that case, we want to dispose immediately.
        let shouldDisposeImmediately = false;
        let disposeWatch = () => {
            shouldDisposeImmediately = true;
        };
        if (!id || !cache) {
            setState({ loading: false });
            return;
        }
        else {
            setState({ loading: true });
        }
        cache
            .searchAndWatch(id, parser ? parsedAccountBaseParser : undefined, isStatic)
            .then(([acc, dispose]) => {
            if (shouldDisposeImmediately) {
                dispose();
                shouldDisposeImmediately = false;
            }
            disposeWatch = dispose;
            if (acc) {
                try {
                    setState({
                        loading: false,
                        info: (parser && parser(acc.pubkey, acc.account)),
                        account: acc.account,
                    });
                }
                catch (e) {
                    console.error("Error while parsing", e);
                    setState({
                        loading: false,
                        info: undefined,
                        account: acc.account
                    });
                }
            }
            else {
                setState({ loading: false });
            }
        })
            .catch((e) => {
            console.error(e);
            setState({ loading: false });
        });
        const disposeEmitter = cache.emitter.onCache((e) => {
            const event = e;
            if (event.id === id) {
                cache.search(id, parser ? parsedAccountBaseParser : undefined).then((acc) => {
                    if (acc && acc.account != state.account) {
                        try {
                            setState({
                                loading: false,
                                info: (parser && parser(acc.pubkey, acc.account)),
                                account: acc.account,
                            });
                        }
                        catch (e) {
                            console.error("Error while parsing", e);
                            setState({
                                loading: false,
                                info: undefined,
                                account: acc.account,
                            });
                        }
                    }
                });
            }
        });
        return () => {
            disposeEmitter();
            setTimeout(disposeWatch, 30 * 1000); // Keep cached accounts around for 30s in case a rerender is causing reuse
        };
    }, [cache, id, !parser]); // only trigger on change to parser if it wasn't defined before.
    return state;
}
exports.useAccount = useAccount;
//# sourceMappingURL=useAccount.js.map