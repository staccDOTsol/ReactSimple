"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PluggableSwap = void 0;
const react_1 = __importStar(require("react"));
const spl_token_1 = require("@solana/spl-token");
const hooks_1 = require("../../hooks");
const Spinner_1 = require("../Spinner");
const icons_1 = require("../icons");
const SwapForm_1 = require("./SwapForm");
const avatar_1 = require("@chakra-ui/avatar");
const spl_token_bonding_1 = require("@strata-foundation/spl-token-bonding");
const PluggableSwap = ({ onConnectWallet, onFlipTokens, onBuyBase, onSuccess, tokenBondingKey, action, }) => {
    const [buy, { loading: buyLoading, error: buyError }] = (0, hooks_1.useBuy)();
    const [sell, { loading: sellLoading, error: sellError }] = (0, hooks_1.useSell)();
    const [internalError, setInternalError] = (0, react_1.useState)();
    const [spendCap, setSpendCap] = (0, react_1.useState)(0);
    const { amount: feeAmount, error: feeError } = (0, hooks_1.useEstimatedFees)(spl_token_1.AccountLayout.span, 1);
    const isBuying = action === "buy";
    const { info: tokenBonding, loading: tokenBondingLoading } = (0, hooks_1.useTokenBonding)(tokenBondingKey);
    const { image: baseImage, metadata: baseMeta, loading: baseMetaLoading, error: baseMetaError, } = (0, hooks_1.useTokenMetadata)(tokenBonding === null || tokenBonding === void 0 ? void 0 : tokenBonding.baseMint);
    const { image: targetImage, metadata: targetMeta, loading: targetMetaLoading, error: targetMetaError, } = (0, hooks_1.useTokenMetadata)(tokenBonding === null || tokenBonding === void 0 ? void 0 : tokenBonding.targetMint);
    const { loading: curveLoading, curve } = (0, hooks_1.useBondingPricing)(tokenBonding === null || tokenBonding === void 0 ? void 0 : tokenBonding.publicKey);
    const targetMint = (0, hooks_1.useMint)(tokenBonding === null || tokenBonding === void 0 ? void 0 : tokenBonding.targetMint);
    const { amount: ownedSol, loading: solLoading } = (0, hooks_1.useSolOwnedAmount)();
    const ownedBaseNormal = (0, hooks_1.useOwnedAmount)(tokenBonding === null || tokenBonding === void 0 ? void 0 : tokenBonding.baseMint);
    const isBaseSol = tokenBonding === null || tokenBonding === void 0 ? void 0 : tokenBonding.baseMint.equals(spl_token_bonding_1.SplTokenBonding.WRAPPED_SOL_MINT);
    const ownedBase = isBaseSol ? ownedSol : ownedBaseNormal;
    const ownedTarget = (0, hooks_1.useOwnedAmount)(tokenBonding === null || tokenBonding === void 0 ? void 0 : tokenBonding.targetMint);
    const { handleErrors } = (0, hooks_1.useErrorHandler)();
    handleErrors(baseMetaError, targetMetaError, buyError, feeError, sellError, internalError);
    (0, react_1.useEffect)(() => {
        if (tokenBonding && targetMint && curve) {
            const purchaseCap = tokenBonding.purchaseCap
                ? (0, hooks_1.amountAsNum)(tokenBonding.purchaseCap, targetMint)
                : Number.POSITIVE_INFINITY;
            const maxSpend = curve.buyTargetAmount(purchaseCap, tokenBonding.buyBaseRoyaltyPercentage, tokenBonding.buyTargetRoyaltyPercentage);
            setSpendCap(maxSpend);
        }
    }, [tokenBonding, targetMint, curve, setSpendCap]);
    if (targetMetaLoading ||
        baseMetaLoading ||
        tokenBondingLoading ||
        curveLoading ||
        solLoading ||
        !tokenBonding ||
        !curve ||
        !baseMeta) {
        return react_1.default.createElement(Spinner_1.Spinner, null);
    }
    const baseInfo = {
        name: (baseMeta === null || baseMeta === void 0 ? void 0 : baseMeta.data.name) || "",
        ticker: (baseMeta === null || baseMeta === void 0 ? void 0 : baseMeta.data.symbol) || "",
        icon: react_1.default.createElement(avatar_1.Avatar, { size: "sm", src: baseImage }),
        publicKey: tokenBonding.baseMint,
    };
    const base = isBaseSol
        ? {
            name: "SOL",
            ticker: "SOL",
            icon: react_1.default.createElement(icons_1.SolanaIcon, { w: "full", h: "full" }),
            publicKey: spl_token_bonding_1.SplTokenBonding.WRAPPED_SOL_MINT,
        }
        : baseInfo;
    const target = {
        name: (targetMeta === null || targetMeta === void 0 ? void 0 : targetMeta.data.name) || "",
        ticker: (targetMeta === null || targetMeta === void 0 ? void 0 : targetMeta.data.symbol) || "",
        icon: react_1.default.createElement(avatar_1.Avatar, { size: "sm", src: targetImage }),
        publicKey: tokenBonding.targetMint,
    };
    const handleSubmit = (values) => __awaiter(void 0, void 0, void 0, function* () {
        const { publicKey } = isBuying ? target : base;
        if (values.topAmount) {
            try {
                if (isBuying) {
                    yield buy(tokenBonding.publicKey, +values.topAmount, +values.slippage / 100);
                }
                else {
                    yield sell(tokenBonding.publicKey, +values.topAmount, +values.slippage / 100);
                }
                onSuccess({
                    mint: publicKey,
                    amount: values.bottomAmount,
                    ticker: isBuying ? target.ticker : base.ticker,
                });
            }
            catch (e) {
                setInternalError(e);
            }
        }
    });
    return (react_1.default.createElement(SwapForm_1.SwapForm, { action: action, isSubmitting: buyLoading || sellLoading, onConnectWallet: onConnectWallet, onFlipTokens: onFlipTokens, onBuyBase: onBuyBase, onSubmit: handleSubmit, tokenBonding: tokenBonding, curve: curve, base: isBuying ? base : target, target: isBuying ? target : base, ownedBase: isBuying ? ownedBase || 0 : ownedTarget || 0, spendCap: spendCap, feeAmount: feeAmount }));
};
exports.PluggableSwap = PluggableSwap;
//# sourceMappingURL=PluggableSwap.js.map