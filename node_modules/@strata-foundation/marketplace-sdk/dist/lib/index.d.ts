import { DataV2 } from "@metaplex-foundation/mpl-token-metadata";
import { Provider } from "@project-serum/anchor";
import { Finality, Keypair, PublicKey } from "@solana/web3.js";
import { ICreateTokenBondingArgs, ICurveConfig, ITokenBonding, SplTokenBonding } from "@strata-foundation/spl-token-bonding";
import { Attribute, BigInstructionResult, InstructionResult, SplTokenMetadata } from "@strata-foundation/spl-utils";
import BN from "bn.js";
export declare type GetBountyItem = {
    tokenBondingKey: PublicKey;
    targetMint: PublicKey;
    baseMint: PublicKey;
    reserveBalanceFromBonding: BN;
    goLiveUnixTime: BN;
};
interface ICreateMarketItemArgs {
    payer?: PublicKey;
    /**
     * Optionally, use this keypair to create the target mint
     */
    targetMintKeypair?: Keypair;
    /**
     * Wallet who will receive the proceeds of this sale. **Default:** provider wallet publicKey
     */
    seller?: PublicKey;
    /**
     * The update authority on the metadata created. **Default:** Seller
     */
    metadataUpdateAuthority?: PublicKey;
    /**
     * The token metadata for the marketplace item
     */
    metadata: DataV2;
    /**
     * The quantity to stop selling at
     */
    quantity?: number;
    /**
     * The price to sell them for. If not provided, should pass `bondingArgs.curve`
     */
    price?: number;
    /**
     * The mint to base the sales off of
     */
    baseMint: PublicKey;
    /**
     * Optionally -- override bonding params
     */
    bondingArgs?: Partial<ICreateTokenBondingArgs>;
}
interface ICreateBountyArgs {
    payer?: PublicKey;
    /**
     * Optionally, use this keypair to create the target mint
     */
    targetMintKeypair?: Keypair;
    /**
     * Wallet who will approve the bounty and disburse the funds
     */
    authority?: PublicKey;
    /**
     * The update authority on the metadata created. **Default:** authority
     */
    metadataUpdateAuthority?: PublicKey;
    /**
     * The token metadata for the marketplace item
     */
    metadata: DataV2;
    /**
     * The mint to base the sales off of
     */
    baseMint: PublicKey;
    /**
     * Optionally -- override bonding params
     */
    bondingArgs?: Partial<ICreateTokenBondingArgs>;
}
interface ILbpCurveArgs {
    /** Max tokens to be sold */
    maxSupply: number;
    /** Interval in seconds to sell them over */
    interval: number;
    /**
     * Starting price
     */
    startPrice: number;
    /**
     * Minimum price (finishing price if no one buys anything)
     */
    minPrice: number;
    /** Optional, the time decay exponential */
    timeDecay?: number;
}
interface ICreateLiquidityBootstrapperArgs extends ILbpCurveArgs {
    payer?: PublicKey;
    /**
     * Optionally, use this keypair to create the target mint
     */
    targetMintKeypair?: Keypair;
    /**
     * Optionally, use this mint. You must have mint authority
     */
    targetMint?: PublicKey;
    /**
     * Wallet who will recieve the funds from the liquidity bootstrapping
     */
    authority?: PublicKey;
    /**
     * The token metadata for the LBP item
     */
    metadata?: DataV2;
    /**
     * The update authority on the metadata created. **Default:** authority
     */
    metadataUpdateAuthority?: PublicKey;
    /**
     * The mint to base the sales off of
     */
    baseMint: PublicKey;
    /**
     * Optionally -- override bonding params
     */
    bondingArgs?: Partial<ICreateTokenBondingArgs>;
}
interface ICreateMetadataForBondingArgs {
    /**
     * The update authority on the metadata created. **Default:** Seller
     */
    metadataUpdateAuthority?: PublicKey;
    /**
     * The token metadata for the marketplace item
     */
    metadata: DataV2;
    /**
     * Optionally, use this keypair to create the target mint
     */
    targetMintKeypair?: Keypair;
    /**
     * Decimals for the mint
     */
    decimals: number;
}
export declare class MarketplaceSdk {
    readonly provider: Provider;
    readonly tokenBondingSdk: SplTokenBonding;
    readonly tokenMetadataSdk: SplTokenMetadata;
    static FIXED_CURVE: string;
    static bountyAttributes({ mint, contact, discussion, }: {
        mint: PublicKey;
        contact: string;
        discussion: string;
    }): Attribute[];
    static init(provider: Provider, splTokenBondingProgramId?: PublicKey): Promise<MarketplaceSdk>;
    constructor(provider: Provider, tokenBondingSdk: SplTokenBonding, tokenMetadataSdk: SplTokenMetadata);
    createFixedCurve({ keypair, }: {
        keypair: Keypair;
    }): Promise<PublicKey>;
    getBounties({ baseMint, }: {
        baseMint?: PublicKey;
    }): Promise<GetBountyItem[]>;
    createMetadataForBondingInstructions({ metadataUpdateAuthority, metadata, targetMintKeypair, decimals, }: ICreateMetadataForBondingArgs): Promise<InstructionResult<{
        metadata: PublicKey;
        mint: PublicKey;
    }>>;
    /**
     * Creates a market item selling a quantity qty for a price
     *
     * @param param0
     * @returns
     */
    createMarketItemInstructions({ payer, seller, metadata, metadataUpdateAuthority, quantity, price, bondingArgs, baseMint, targetMintKeypair, }: ICreateMarketItemArgs): Promise<BigInstructionResult<{
        tokenBonding: PublicKey;
    }>>;
    /**
     * Executes `createMarketItemIntructions`
     * @param args
     * @returns
     */
    createMarketItem(args: ICreateMarketItemArgs, finality?: Finality): Promise<{
        tokenBonding: PublicKey;
    }>;
    static isNormalBounty(tokenBonding: ITokenBonding | undefined): boolean;
    /**
     * Creates a bounty
     *
     * @param param0
     * @returns
     */
    createBountyInstructions({ payer, authority, targetMintKeypair, metadata, metadataUpdateAuthority, bondingArgs, baseMint, }: ICreateBountyArgs): Promise<BigInstructionResult<{
        tokenBonding: PublicKey;
        targetMint: PublicKey;
    }>>;
    /**
     * Executes `createBountyIntructions`
     * @param args
     * @returns
     */
    createBounty(args: ICreateBountyArgs, finality?: Finality): Promise<{
        tokenBonding: PublicKey;
        targetMint: PublicKey;
    }>;
    static lbcCurve({ interval, startPrice, minPrice, maxSupply, timeDecay }: ILbpCurveArgs): {
        reserves: number;
        supply: number;
        curveConfig: ICurveConfig;
    };
    /**
     * Creates an LBP
     *
     * @param param0
     * @returns
     */
    createLiquidityBootstrapperInstructions({ payer, authority, targetMint, targetMintKeypair, metadata, metadataUpdateAuthority, interval, startPrice, minPrice, maxSupply, bondingArgs, baseMint, }: ICreateLiquidityBootstrapperArgs): Promise<BigInstructionResult<{
        tokenBonding: PublicKey;
        targetMint: PublicKey;
    }>>;
    /**
     * Executes `createLiquidityBootstrapperIntructions`
     * @param args
     * @returns
     */
    createLiquidityBootstrapper(args: ICreateLiquidityBootstrapperArgs, finality?: Finality): Promise<{
        tokenBonding: PublicKey;
        targetMint: PublicKey;
    }>;
}
export {};
//# sourceMappingURL=index.d.ts.map