'use strict';

exports.__esModule = true;

var _identicon = require('identicon.js');

var _identicon2 = _interopRequireDefault(_identicon);

var _Attribute = require('./Attribute');

var _Attribute2 = _interopRequireDefault(_Attribute);

var _util = require('./util');

var _util2 = _interopRequireDefault(_util);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
* An Iris Contact, such as person, organization or group. More abstractly speaking: an Identity.
*
* Usually you don't create Contacts yourself, but get them
* from SocialNetwork methods such as get() and search().
*/
var Contact = function () {
  /**
  * @param {Object} gun node where the Contact data lives
  */
  function Contact(gun, linkTo) {
    _classCallCheck(this, Contact);

    this.gun = gun;
    this.linkTo = linkTo;
  }

  Contact.create = function create(gun, data, index) {
    if (!data.linkTo && !data.attrs) {
      throw new Error('You must specify either data.linkTo or data.attrs');
    }
    if (data.linkTo && !data.attrs) {
      var linkTo = new _Attribute2.default(data.linkTo);
      data.attrs = {};
      if (!Object.prototype.hasOwnProperty.call(data.attrs, linkTo.uri())) {
        data.attrs[linkTo.uri()] = linkTo;
      }
    } else {
      data.linkTo = Contact.getLinkTo(data.attrs);
    }
    var uri = data.linkTo.uri();
    var attrs = gun.top(uri + '/attrs').put(data.attrs);
    delete data['attrs'];
    gun.put(data);
    gun.get('attrs').put(attrs);
    return new Contact(gun, uri, index);
  };

  Contact.getLinkTo = function getLinkTo(attrs) {
    var mva = Contact.getMostVerifiedAttributes(attrs);
    var keys = Object.keys(mva);
    var linkTo = void 0;
    for (var i = 0; i < keys.length; i++) {
      if (keys[i] === 'keyID') {
        linkTo = mva[keys[i]].attribute;
        break;
      } else if (_Attribute2.default.isUniqueType(keys[i])) {
        linkTo = mva[keys[i]].attribute;
      }
    }
    return linkTo;
  };

  Contact.getMostVerifiedAttributes = function getMostVerifiedAttributes(attrs) {
    var mostVerifiedAttributes = {};
    Object.keys(attrs).forEach(function (k) {
      var a = attrs[k];
      var keyExists = Object.keys(mostVerifiedAttributes).indexOf(a.type) > -1;
      a.verifications = isNaN(a.verifications) ? 1 : a.verifications;
      a.unverifications = isNaN(a.unverifications) ? 0 : a.unverifications;
      if (a.verifications * 2 > a.unverifications * 3 && (!keyExists || a.verifications - a.unverifications > mostVerifiedAttributes[a.type].verificationScore)) {
        mostVerifiedAttributes[a.type] = {
          attribute: a,
          verificationScore: a.verifications - a.unverifications
        };
        if (a.verified) {
          mostVerifiedAttributes[a.type].verified = true;
        }
      }
    });
    return mostVerifiedAttributes;
  };

  Contact.getAttrs = async function getAttrs(identity) {
    var attrs = await _util2.default.loadGunDepth(identity.get('attrs'), 2);
    if (attrs && attrs['_'] !== undefined) {
      delete attrs['_'];
    }
    return attrs || {};
  };

  Contact.prototype.getId = function getId() {
    return this.linkTo.value;
  };

  /**
  * Get sent Messages
  * @param {Object} index
  * @param {Object} options
  */


  Contact.prototype.sent = function sent(index, options) {
    index._getSentMsgs(this, options);
  };

  /**
  * Get received Messages
  * @param {Object} index
  * @param {Object} options
  */


  Contact.prototype.received = function received(index, options) {
    index._getReceivedMsgs(this, options);
  };

  /**
  * @param {string} attribute attribute type
  * @returns {string} most verified value of the param type
  */


  Contact.prototype.verified = async function verified(attribute) {
    var attrs = await Contact.getAttrs(this.gun).then();
    var mva = Contact.getMostVerifiedAttributes(attrs);
    return Object.prototype.hasOwnProperty.call(mva, attribute) ? mva[attribute].attribute.value : undefined;
  };

  /**
  * @returns {HTMLElement} profile card html element describing the identity
  */


  Contact.prototype.profileCard = function profileCard() {
    var _this = this;

    var card = document.createElement('div');
    card.className = 'iris-card';

    var identicon = this.identicon({ width: 60 });
    identicon.style.order = 1;
    identicon.style.flexShrink = 0;
    identicon.style.marginRight = '15px';

    var details = document.createElement('div');
    details.style.padding = '5px';
    details.style.order = 2;
    details.style.flexGrow = 1;

    var linkEl = document.createElement('span');
    var links = document.createElement('small');
    card.appendChild(identicon);
    card.appendChild(details);
    details.appendChild(linkEl);
    details.appendChild(links);

    this.gun.on(async function (data) {
      if (!data) {
        return;
      }
      var attrs = await Contact.getAttrs(_this.gun);
      var linkTo = await _this.gun.get('linkTo').then();
      var link = 'https://iris.to/#/identities/' + linkTo.type + '/' + linkTo.value;
      var mva = Contact.getMostVerifiedAttributes(attrs);
      linkEl.innerHTML = '<a href="' + link + '">' + (mva.type && mva.type.attribute.value || mva.nickname && mva.nickname.attribute.value || linkTo.type + ':' + linkTo.value) + '</a><br>';
      linkEl.innerHTML += '<small>Received: <span class="iris-pos">+' + (data.receivedPositive || 0) + '</span> / <span class="iris-neg">-' + (data.receivedNegative || 0) + '</span></small><br>';
      links.innerHTML = '';
      Object.keys(attrs).forEach(function (k) {
        var a = attrs[k];
        if (a.link) {
          links.innerHTML += a.type + ': <a href="' + a.link + '">' + a.value + '</a> ';
        }
      });
    });

    /*
    const template = ```
    <tr ng-repeat="result in ids.list" id="result{$index}" ng-hide="!result.linkTo" ui-sref="identities.show({ type: result.linkTo.type, value: result.linkTo.value })" class="search-result-row" ng-class="{active: result.active}">
      <td class="gravatar-col"><identicon id="result" border="3" width="46" positive-score="result.pos" negative-score="result.neg"></identicon></td>
      <td>
        <span ng-if="result.distance == 0" class="label label-default pull-right">rootContact</span>
        <span ng-if="result.distance > 0" ng-bind="result.distance | ordinal" class="label label-default pull-right"></span>
        <a ng-bind-html="result.name|highlight:query.term" ui-sref="identities.show({ type: result.linkTo.type, value: result.linkTo.value })"></a>
        <small ng-if="!result.name" class="list-group-item-text">
          <span ng-bind-html="result[0][0]|highlight:query.term"></span>
        </small><br>
        <small>
          <span ng-if="result.nickname && result.name != result.nickname" ng-bind-html="result.nickname|highlight:query.term" class="mar-right10"></span>
          <span ng-if="result.email" class="mar-right10">
            <span class="glyphicon glyphicon-envelope"></span> <span ng-bind-html="result.email|highlight:query.term"></span>
          </span>
          <span ng-if="result.facebook" class="mar-right10">
            <span class="fa fa-facebook"></span> <span ng-bind-html="result.facebook|highlight:query.term"></span>
          </span>
          <span ng-if="result.twitter" class="mar-right10">
            <span class="fa fa-twitter"></span> <span ng-bind-html="result.twitter|highlight:query.term"></span>
          </span>
          <span ng-if="result.googlePlus" class="mar-right10">
            <span class="fa fa-google-plus"></span> <span ng-bind-html="result.googlePlus|highlight:query.term"></span>
          </span>
          <span ng-if="result.bitcoin" class="mar-right10">
            <span class="fa fa-bitcoin"></span> <span ng-bind-html="result.bitcoin|highlight:query.term"></span>
          </span>
        </small>
      </td>
    </tr>
    ```;*/
    return card;
  };

  /**
  * Appends an identity search widget to the given HTMLElement
  * @param {HTMLElement} parentElement element where the search widget is added and event listener attached
  * @param {Index} index index root to use for search
  */


  Contact.appendSearchWidget = function appendSearchWidget(parentElement, index) {
    var form = document.createElement('form');

    var input = document.createElement('input');
    input.type = 'text';
    input.placeholder = 'Search';
    input.id = 'irisSearchInput';
    form.innerHTML += '<div id="irisSearchResults"></div>';

    var searchResults = document.createElement('div');

    parentElement.appendChild(form);
    form.appendChild(input);
    form.appendChild(searchResults);
    input.addEventListener('keyup', async function () {
      var r = await index.search(input.value);
      searchResults.innerHTML = '';
      r.sort(function (a, b) {
        return a.trustDistance - b.trustDistance;
      });
      r.forEach(function (i) {
        searchResults.appendChild(i.profileCard());
      });
    });

    return form;
  };

  Contact._ordinal = function _ordinal(n) {
    if (n === 0) {
      return '';
    }
    var s = ['th', 'st', 'nd', 'rd'];
    var v = n % 100;
    return n + (s[(v - 20) % 10] || s[v] || s[0]);
  };

  /**
  * @param {Object} options {width: 50, border: 4, showDistance: true, outerGlow: false}
  * @returns {HTMLElement} identicon element that can be appended to DOM
  */


  Contact.prototype.identicon = function identicon() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    options = Object.assign({
      width: 50,
      border: 4,
      showDistance: true,
      outerGlow: false
    }, options);
    _util2.default.injectCss(); // some other way that is not called on each identicon generation?
    var identicon = document.createElement('div');
    identicon.className = 'iris-identicon';
    identicon.style.width = options.width + 'px';
    identicon.style.height = options.width + 'px';

    var pie = document.createElement('div');
    pie.className = 'iris-pie';
    pie.style.width = options.width + 'px';

    var img = document.createElement('img');
    img.alt = '';
    img.width = options.width;
    img.height = options.width;
    img.style.borderWidth = options.border + 'px';

    var distance = void 0;
    if (options.border) {
      distance = document.createElement('span');
      distance.className = 'iris-distance';
      distance.style.fontSize = options.width > 50 ? options.width / 4 + 'px' : '10px';
      identicon.appendChild(distance);
    }
    identicon.appendChild(pie);
    identicon.appendChild(img);

    function setPie(data) {
      if (!data) {
        return;
      }
      // Define colors etc
      var bgColor = 'rgba(0,0,0,0.2)';
      var bgImage = 'none';
      var transform = '';
      if (options.outerGlow) {
        var boxShadow = '0px 0px 0px 0px #82FF84';
        if (data.receivedPositive > data.receivedNegative * 20) {
          boxShadow = '0px 0px ' + options.border * data.receivedPositive / 50 + 'px 0px #82FF84';
        } else if (data.receivedPositive < data.receivedNegative * 3) {
          boxShadow = '0px 0px ' + options.border * data.receivedNegative / 10 + 'px 0px #BF0400';
        }
        pie.style.boxShadow = boxShadow;
      }
      if (data.receivedPositive + data.receivedNegative > 0) {
        if (data.receivedPositive > data.receivedNegative) {
          transform = 'rotate(' + (-data.receivedPositive / (data.receivedPositive + data.receivedNegative) * 360 - 180) / 2 + 'deg)';
          bgColor = '#A94442';
          bgImage = 'linear-gradient(' + data.receivedPositive / (data.receivedPositive + data.receivedNegative) * 360 + 'deg, transparent 50%, #3C763D 50%), linear-gradient(0deg, #3C763D 50%, transparent 50%)';
        } else {
          transform = 'rotate(' + ((-data.receivedNegative / (data.receivedPositive + data.receivedNegative) * 360 - 180) / 2 + 180) + 'deg)';
          bgColor = '#3C763D';
          bgImage = 'linear-gradient(' + data.receivedNegative / (data.receivedPositive + data.receivedNegative) * 360 + 'deg, transparent 50%, #A94442 50%), linear-gradient(0deg, #A94442 50%, transparent 50%)';
        }
      }

      pie.style.backgroundColor = bgColor;
      pie.style.backgroundImage = bgImage;
      pie.style.transform = transform;
      pie.style.opacity = (data.receivedPositive + data.receivedNegative) / 10 * 0.5 + 0.35;

      if (options.showDistance) {
        distance.textContent = typeof data.trustDistance === 'number' ? Contact._ordinal(data.trustDistance) : '\u2715';
      }
    }

    function setIdenticonImg(data) {
      _util2.default.getHash(encodeURIComponent(data.type) + ':' + encodeURIComponent(data.value), 'hex').then(function (hash) {
        var identiconImg = new _identicon2.default(hash, { width: options.width, format: 'svg' });
        img.src = img.src || 'data:image/svg+xml;base64,' + identiconImg.toString();
      });
    }

    if (this.linkTo) {
      setIdenticonImg(this.linkTo);
    } else {
      this.gun.get('linkTo').on(setIdenticonImg);
    }

    this.gun.on(setPie);

    return identicon;
  };

  Contact.prototype.serialize = function serialize() {
    return this.gun;
  };

  Contact.deserialize = function deserialize(data, opt) {
    var linkTo = new _Attribute2.default({ type: 'uuid', value: opt.id });
    return new Contact(opt.gun, linkTo);
  };

  return Contact;
}();

exports.default = Contact;
module.exports = exports['default'];