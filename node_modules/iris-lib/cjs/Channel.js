'use strict';

exports.__esModule = true;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _gun = require('gun');

var _gun2 = _interopRequireDefault(_gun);

require('gun/sea');

var _util = require('./util');

var _util2 = _interopRequireDefault(_util);

var _Attribute = require('./Attribute');

var _Attribute2 = _interopRequireDefault(_Attribute);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
* Private communication channel between two or more participants ([Gun](https://github.com/amark/gun) public keys). Can be used independently of other Iris stuff.
*
* Used as a core element of [iris-messenger](https://github.com/irislib/iris-messenger).
*
* ---
*
* #### Key-value API
* `channel.put(key, value)` and `channel.on(key, callback)`.
*
* Note that each participant has their own versions of each key-value — they don't overwrite each other. `channel.on()` callback returns them all by default and has a parameter that indicates whose value you got.
*
* While values are encrypted, encryption of keys is not implemented yet.
*
* #### Message API
* `channel.send()` and `channel.getMessages()` for timestamp-indexed chat-style messaging.
*
* Message data is encrypted, but timestamps are public so that peers can return your messages in a sequential order.
*
* ---
*
* You can open a channel with yourself for a private key-value space or a "note to self" type chat with yourself.
*
* **Note!** As of April 2020 Gun.SEA hashing function [is broken on Safari](https://github.com/amark/gun/issues/892). Channels don't work on Safari unless you patch sea.js by adding [this line](https://github.com/irislib/iris-messenger/blob/1e012581793485e6b8b5ed3c2ad0629716709366/src/js/sea.js#L270).
*
* **Privacy disclaimer:** Channel ids, data values and messages are encrypted, but message timestamps are unencrypted so that peers can return them to you in a sequential order. By looking at the unencrypted timestamps (or Gun subscriptions), it is possible to guess who are communicating with each other. This could be improved by indexing messages by *day* only, so making the guess would be more difficult, while you could still return them in a semi-sequential order.
*
* @param {Object} options
* @param {string} options.key your keypair
* @param {Object} options.gun [gun](https://github.com/amark/gun) instance
* @param options.participants (optional) string or string array or permissions object ({'pub1':{read:true,write:true,admin:false},'pub2'...}) of participant public keys (your own key is included by default)
* @param {string} options.chatLink (optional) chat link instead of participants list
* @param {string} options.uuid (group channels only) unique channel identifier. Leave out for new channel.
* @param {string} options.name (group channels only) channel name
* @example
* // Copy & paste this to console at https://iris.to or other page that has gun, sea and iris-lib
* // Due to an unsolved bug, someoneElse's messages only start showing up after a reload
*
* var gun1 = new Gun('https://gun-us.herokuapp.com/gun');
* var gun2 = new Gun('https://gun-us.herokuapp.com/gun');
* var myKey = await iris.Key.getDefault();
* var someoneElse = localStorage.getItem('someoneElsesKey');
* if (someoneElse) {
*  someoneElse = JSON.parse(someoneElse);
* } else {
*  someoneElse = await iris.Key.generate();
*  localStorage.setItem('someoneElsesKey', JSON.stringify(someoneElse));
* }
*
* iris.Channel.initUser(gun1, myKey); // saves myKey.epub to gun.user().get('epub')
* iris.Channel.initUser(gun2, someoneElse);
*
* var ourChannel = new iris.Channel({key: myKey, gun: gun1, participants: someoneElse.pub});
* var theirChannel = new iris.Channel({key: someoneElse, gun: gun2, participants: myKey.pub});
*
* var myChannels = {}; // you can list them in a user interface
* function printMessage(msg, info) {
*  console.log(`[${new Date(msg.time).toLocaleString()}] ${info.from.slice(0,8)}: ${msg.text}`)
* }
* iris.Channel.getChannels(gun1, myKey, channel => {
*  var pub = channel.getCurrentParticipants()[0];
*  gun1.user(pub).get('profile').get('name').on(name => channel.name = name);
*  myChannels[pub] = channel;
*  channel.getMessages(printMessage);
*  channel.on('mood', (mood, from) => console.log(from.slice(0,8) + ' is feeling ' + mood));
* });
*
* // you can play with these in the console:
* ourChannel.send('message from myKey');
* theirChannel.send('message from someoneElse');
*
* ourChannel.put('mood', 'blessed');
* theirChannel.put('mood', 'happy');
*
* @example https://github.com/irislib/iris-lib/blob/master/__tests__/Channel.js
*/
var Channel = function () {
  function Channel(options) {
    var _this = this;

    _classCallCheck(this, Channel);

    this.DEFAULT_PERMISSIONS = { read: true, write: true };
    this.key = options.key;
    this.gun = options.gun;
    this.myGroupSecret = options.myGroupSecret;
    this.theirSecretUuids = {};
    this.theirGroupSecrets = {};
    this.user = this.gun.user();
    this.user.auth(this.key);
    this.user.put({ epub: this.key.epub });
    this.secrets = {}; // maps participant public key to shared secret
    this.ourSecretChannelIds = {}; // maps participant public key to our secret mutual channel id
    this.theirSecretChannelIds = {}; // maps participant public key to their secret mutual channel id
    this.messages = {};
    this.chatLinks = {};
    this.groupSubscriptions = {};
    this.directSubscriptions = {};
    this.getParticipantsCallbacks = {};

    if (options.chatLink) {
      this.useChatLink(options);
    }

    if (typeof options.participants === 'string') {
      this.addParticipant(options.participants, options.save);
    } else if (Array.isArray(options.participants)) {
      var o = {};
      options.participants.forEach(function (p) {
        return o[p] = Object.assign({}, _this.DEFAULT_PERMISSIONS);
      });
      options.participants = o;
    }
    if (typeof options.participants === 'object') {
      // it's a group channel
      var keys = Object.keys(options.participants);
      keys.forEach(function (k) {
        if (k !== _this.key.pub) {
          _this.addParticipant(k, options.save, Object.assign({}, _this.DEFAULT_PERMISSIONS, options.participants[k]));
        }
      });
      options.participants[this.key.pub] = options.participants[this.key.pub] || Object.assign({}, this.DEFAULT_PERMISSIONS);
      if (options.uuid) {
        this.uuid = options.uuid;
        this.name = options.name;
      } else {
        options.uuid = _Attribute2.default.getUuid().value;
        this.uuid = options.uuid;
        options.participants[this.key.pub].admin = true;
        options.participants[this.key.pub].founder = true;
      }
      this.getChatLinks({ subscribe: true });
    }
    this.participants = options.participants;
    if (options.uuid) {
      // It's a group channel
      // share secret uuid with other participants. since secret is already non-deterministic, maybe uuid could also be?
      // generate channel-specific secret and share it with other participants
      // put() keys should be encrypted first? so you could do put(uuid, secret)
      // what if you join the channel with 2 unconnected devices? on reconnect, the older secret would be overwritten and messages unreadable. maybe participants should store each others' old keys? or maybe you should store them and re-encrypt old stuff when key changes? return them with map() instead?
      this.putDirect('S' + this.uuid, this.getMyGroupSecret());
      this.getMySecretUuid().then(function (s) {
        _this.putDirect(_this.uuid, s); // TODO: encrypt keys in put()
      });
      this.onTheirDirect(this.uuid, function (s, k, from) {
        _this.theirSecretUuids[from] = s;
      });
      this.onTheirDirect('S' + this.uuid, function (s, k, from) {
        _this.theirGroupSecrets[from] = s;
      });
      // need to make put(), on(), send() and getMessages() behave differently when it's a group and retain the old versions for mutual signaling
    }
    this.onTheir('participants', function (participants, k, from) {
      var hasAdmin = false;
      var keys = Object.keys(_this.participants);
      for (var i = 0; i < keys.length; i++) {
        if (_this.participants[keys[i]].admin || _this.participants[keys[i]].inviter) {
          hasAdmin = true;
          break;
        }
      }
      if (!hasAdmin) {
        keys.forEach(function (k) {
          return _this.participants[k].admin = true;
        }); // if no admins, make everyone admin
      }
      if (_this.participants[from] && (_this.participants[from].admin || _this.participants[from].inviter)) {
        if (typeof participants === 'object') {
          if (JSON.stringify(_this.participants) === JSON.stringify(participants)) {
            return;
          }
          _this.participants = participants;
          delete _this.participants[from].inviter;
          Object.keys(participants).forEach(function (k) {
            if (k !== _this.key.pub) {
              _this.addParticipant(k, true, Object.assign({}, _this.DEFAULT_PERMISSIONS, participants[k]), true);
            }
          });
          _this.participantsChanged();
          options.saved = true;
        }
      }
    });
    if (!options.saved && (options.save === undefined || options.save === true)) {
      this.save();
    }
  }

  Channel.prototype.useChatLink = function useChatLink(options) {
    var _this2 = this;

    var s = options.chatLink.split('?');
    if (s.length === 2) {
      var chatWith = _util2.default.getUrlParameter('chatWith', s[1]);
      var channelId = _util2.default.getUrlParameter('channelId', s[1]);
      var inviter = _util2.default.getUrlParameter('inviter', s[1]);
      var pub = inviter || chatWith;
      if (chatWith) {
        options.participants = pub;
      } else if (channelId && inviter && inviter !== this.key.pub) {
        // TODO! initializing it twice breaks things - new secret is generated
        options.uuid = channelId;
        options.participants = {};
        options.participants[inviter] = Object.assign({ inviter: true }, this.DEFAULT_PERMISSIONS);
      }
      if (pub !== this.key.pub) {
        var sharedSecret = _util2.default.getUrlParameter('s', s[1]);
        var linkId = _util2.default.getUrlParameter('k', s[1]);
        if (sharedSecret && linkId) {
          this.save(); // save the channel first so it's there before inviter subscribes to it
          options.saved = true;
          this.gun.user(pub).get('chatLinks').get(linkId).get('encryptedSharedKey').on(async function (encrypted) {
            var sharedKey = await _gun2.default.SEA.decrypt(encrypted, sharedSecret);
            var encryptedChatRequest = await _gun2.default.SEA.encrypt(_this2.key.pub, sharedSecret); // TODO encrypt is not deterministic, it uses salt
            var channelRequestId = await _util2.default.getHash(encryptedChatRequest);
            _util2.default.gunAsAnotherUser(_this2.gun, sharedKey, function (user) {
              user.get('chatRequests').get(channelRequestId.slice(0, 12)).put(encryptedChatRequest);
            });
          });
        }
      }
    }
  };

  Channel.prototype.getTheirSecretUuid = function getTheirSecretUuid(pub) {
    var _this3 = this;

    return new Promise(function (resolve) {
      if (!_this3.theirSecretUuids[pub]) {
        _this3.onTheirDirect(_this3.uuid, function (s) {
          _this3.theirSecretUuids[pub] = s;
          resolve(_this3.theirSecretUuids[pub]);
        }, pub);
      } else {
        resolve(_this3.theirSecretUuids[pub]);
      }
    });
  };

  Channel.prototype.getTheirGroupSecret = function getTheirGroupSecret(pub) {
    var _this4 = this;

    if (pub === this.key.pub) {
      return this.getMyGroupSecret();
    }
    return new Promise(function (resolve) {
      if (!_this4.theirGroupSecrets[pub]) {
        _this4.onTheirDirect('S' + _this4.uuid, function (s) {
          _this4.theirGroupSecrets[pub] = s;
          resolve(_this4.theirGroupSecrets[pub]);
        }, pub);
      } else {
        resolve(_this4.theirGroupSecrets[pub]);
      }
    });
  };

  Channel.prototype.changeMyGroupSecret = function changeMyGroupSecret() {
    this.myGroupSecret = _gun2.default.SEA.random(32).toString('base64');
    // TODO: secret should be archived and probably messages should include the encryption key id so past messages don't become unreadable
    this.putDirect('S' + this.uuid, this.myGroupSecret);
  };

  /**
  * Unsubscribe messages from a channel participants
  *
  * @param {string} participant public key
  */


  Channel.prototype.mute = async function mute(participant) {
    this.gun.user(participant).get(this.theirSecretUuids[participant]).off();
    // TODO: persist
  };

  /**
  * Mute user and prevent them from seeing your further (and maybe past) messages
  *
  * @param {string} participant public key
  */


  Channel.prototype.block = async function block(participant) {
    this.mute(participant);
    this.putDirect(this.uuid, null);
    this.putDirect('S' + this.uuid, null);
    delete this.secrets[participant];
    delete this.ourSecretChannelIds[participant];
    delete this.theirSecretChannelIds[participant];
    this.changeMyGroupSecret();
  };

  Channel.prototype.getMySecretUuid = async function getMySecretUuid() {
    if (!this.mySecretUuid) {
      var mySecret = await _gun2.default.SEA.secret(this.key.epub, this.key);
      var mySecretHash = await _util2.default.getHash(mySecret);
      this.mySecretUuid = await _util2.default.getHash(mySecretHash + this.uuid);
    }
    return this.mySecretUuid;
  };

  /**
  * List participants of the channel (other than you)
  */


  Channel.prototype.getCurrentParticipants = function getCurrentParticipants() {
    return Object.keys(this.secrets);
  };

  /**
  * Subscribe to the changing list of participants by channel admins
  */


  Channel.prototype.getParticipants = function getParticipants(callback) {
    if (this.getParticipantsCallbackId) {
      this.getParticipantsCallbackId++;
    } else {
      this.getParticipantsCallbackId = 1;
    }
    this.getParticipantsCallbacks[this.getParticipantsCallbackId] = callback;
    if (this.participants) {
      callback(this.participants);
    }
  };

  Channel.prototype.participantsChanged = function participantsChanged() {
    var _this5 = this;

    Object.keys(this.getParticipantsCallbacks).forEach(function (id) {
      _this5.getParticipantsCallbacks[id](_this5.participants);
    });
  };

  /**
  * Returns either the uuid of a group channel or the public key of a direct channel.
  */


  Channel.prototype.getId = function getId() {
    return this.uuid || this.getCurrentParticipants()[0];
  };

  Channel.prototype.getSecret = async function getSecret(pub) {
    if (!this.secrets[pub]) {
      var epub = await _util2.default.gunOnceDefined(this.gun.user(pub).get('epub'));
      this.secrets[pub] = await _gun2.default.SEA.secret(epub, this.key);
    }
    return this.secrets[pub];
  };

  /**
  *
  */


  Channel.getOurSecretChannelId = async function getOurSecretChannelId(gun, pub, pair) {
    var epub = await _util2.default.gunOnceDefined(gun.user(pub).get('epub'));
    var secret = await _gun2.default.SEA.secret(epub, pair);
    return _util2.default.getHash(secret + pub);
  };

  /**
  *
  */


  Channel.getTheirSecretChannelId = async function getTheirSecretChannelId(gun, pub, pair) {
    var epub = await _util2.default.gunOnceDefined(gun.user(pub).get('epub'));
    var secret = await _gun2.default.SEA.secret(epub, pair);
    return _util2.default.getHash(secret + pair.pub);
  };

  /**
  * Calls back with Channels that you have initiated or written to.
  * @param {Object} gun user.authed gun instance
  * @param {Object} keypair Gun.SEA keypair that the gun instance is authenticated with
  * @param callback callback function that is called for each public key you have a channel with
  */


  Channel.getChannels = async function getChannels(gun, keypair, callback) {
    var listenToChatLinks = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

    var mySecret = await _gun2.default.SEA.secret(keypair.epub, keypair);
    if (listenToChatLinks) {
      Channel.getMyChatLinks(gun, keypair, undefined, undefined, true);
    }
    var seen = {};
    gun.user().get('chats').map().on(async function (value, ourSecretChannelId) {
      if (value && !seen[ourSecretChannelId]) {
        seen[ourSecretChannelId] = true;
        if (ourSecretChannelId.length > 44) {
          gun.user().get('chats').get(ourSecretChannelId).put(null);
          return;
        }
        var encryptedChatId = await _util2.default.gunOnceDefined(gun.user().get('chats').get(ourSecretChannelId).get('pub'));
        var chatId = await _gun2.default.SEA.decrypt(encryptedChatId, mySecret);
        if (chatId.pub || typeof chatId === 'string') {
          callback(new Channel({
            key: keypair,
            gun: gun,
            participants: chatId.pub || chatId,
            save: false
          }));
        } else {
          if (chatId.uuid && chatId.participants && chatId.myGroupSecret) {
            callback(new Channel({
              key: keypair,
              gun: gun,
              participants: chatId.participants,
              uuid: chatId.uuid,
              myGroupSecret: chatId.myGroupSecret,
              save: false
            }));
          }
        }
      }
    });
  };

  Channel.prototype.getMyGroupSecret = function getMyGroupSecret() {
    // group secret could be deterministic: hash(encryptToSelf(uuid + iterator))
    if (!this.myGroupSecret) {
      this.changeMyGroupSecret();
    }
    return this.myGroupSecret;
  };

  Channel.prototype.getOurSecretChannelId = async function getOurSecretChannelId(pub) {
    if (!this.ourSecretChannelIds[pub]) {
      var secret = await this.getSecret(pub);
      this.ourSecretChannelIds[pub] = await _util2.default.getHash(secret + pub);
    }
    return this.ourSecretChannelIds[pub];
  };

  Channel.prototype.getTheirSecretChannelId = async function getTheirSecretChannelId(pub) {
    if (!this.theirSecretChannelIds[pub]) {
      var secret = await this.getSecret(pub);
      this.theirSecretChannelIds[pub] = await _util2.default.getHash(secret + this.key.pub);
    }
    return this.theirSecretChannelIds[pub];
  };

  /**
  * Get messages from the channel
  */


  Channel.prototype.getMessages = async function getMessages(callback) {
    var _this6 = this;

    // TODO: save callback and apply it when new participants are added to channel
    this.getCurrentParticipants().forEach(async function (pub) {
      if (pub !== _this6.key.pub) {
        // Subscribe to their messages
        var theirSecretChannelId = void 0;
        if (_this6.uuid) {
          theirSecretChannelId = await _this6.getTheirSecretUuid(pub);
        } else {
          theirSecretChannelId = await _this6.getTheirSecretChannelId(pub);
        }
        _this6.gun.user(pub).get('chats').get(theirSecretChannelId).get('msgs').map().once(function (data, key) {
          _this6.messageReceived(callback, data, _this6.uuid || pub, false, key, pub);
        });
      }
      if (!_this6.uuid) {
        // Subscribe to our messages
        var ourSecretChannelId = await _this6.getOurSecretChannelId(pub);
        _this6.user.get('chats').get(ourSecretChannelId).get('msgs').map().once(function (data, key) {
          _this6.messageReceived(callback, data, pub, true, key, _this6.key.pub);
        });
      }
    });
    if (this.uuid) {
      // Subscribe to our messages
      var mySecretUuid = await this.getMySecretUuid();
      this.user.get('chats').get(mySecretUuid).get('msgs').map().once(function (data, key) {
        _this6.messageReceived(callback, data, _this6.uuid, true, key, _this6.key.pub);
      });
    }
  };

  Channel.prototype.messageReceived = async function messageReceived(callback, data, channelId, selfAuthored, key, from) {
    if (this.messages[key] || !data) {
      return;
    }
    var secret = this.uuid ? await this.getTheirGroupSecret(from) : await this.getSecret(channelId);
    var decrypted = await _gun2.default.SEA.decrypt(data, secret);
    if (typeof decrypted !== 'object') {
      return;
    }
    var info = { selfAuthored: selfAuthored, channelId: channelId, from: from };
    this.messages[key] = decrypted;
    callback(decrypted, info);
  };

  /**
  * Get latest message in this channel. Useful for channel listing.
  */


  Channel.prototype.getLatestMsg = async function getLatestMsg(callback) {
    var _this7 = this;

    var callbackIfLatest = async function callbackIfLatest(msg, info) {
      if (!_this7.latest) {
        _this7.latest = msg;
        callback(msg, info);
      } else {
        var t = typeof _this7.latest.time === 'string' ? _this7.latest.time : _this7.latest.time.toISOString();
        if (t < msg.time) {
          _this7.latest = msg;
          callback(msg, info);
        }
      }
    };
    this.onMy('latestMsg', function (msg) {
      return callbackIfLatest(msg, { selfAuthored: true, from: _this7.key.pub });
    });
    this.onTheir('latestMsg', function (msg, k, from) {
      return callbackIfLatest(msg, { selfAuthored: false, from: from });
    });
  };

  /**
  * Useful for notifications
  * @param {integer} time last seen msg time (default: now)
  */


  Channel.prototype.setMyMsgsLastSeenTime = async function setMyMsgsLastSeenTime(time) {
    time = time || new Date().toISOString();
    return this.put('msgsLastSeenTime', time);
  };

  /**
  * Useful for notifications
  */


  Channel.prototype.getMyMsgsLastSeenTime = async function getMyMsgsLastSeenTime(callback) {
    var _this8 = this;

    this.onMy('msgsLastSeenTime', function (time) {
      _this8.myMsgsLastSeenTime = time;
      if (callback) {
        callback(_this8.myMsgsLastSeenTime);
      }
    });
  };

  /**
  * For "seen" status indicator
  */


  Channel.prototype.getTheirMsgsLastSeenTime = async function getTheirMsgsLastSeenTime(callback) {
    var _this9 = this;

    this.onTheir('msgsLastSeenTime', function (time) {
      _this9.theirMsgsLastSeenTime = time;
      if (callback) {
        callback(_this9.theirMsgsLastSeenTime);
      }
    });
  };

  Channel.prototype.removeParticipant = async function removeParticipant(pub) {
    this.addParticipant(pub, true, { read: false, write: false });
  };

  /**
  * Add a public key to the channel or update its permissions
  * @param {string} pub
  */


  Channel.prototype.addParticipant = async function addParticipant(pub) {
    var save = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

    var _this10 = this;

    var permissions = arguments[2];
    var subscribe = arguments[3];

    if (permissions === undefined) {
      permissions = this.DEFAULT_PERMISSIONS;
    }
    if (this.secrets[pub] && JSON.stringify(this.secrets[pub]) === JSON.stringify(permissions)) {
      // TODO: should be this.participants[pub]
      return;
    }
    this.secrets[pub] = null;
    this.getSecret(pub);
    var ourSecretChannelId = await this.getOurSecretChannelId(pub);
    if (save) {
      // Save their public key in encrypted format, so in channel listing we know who we are channeling with
      var mySecret = await _gun2.default.SEA.secret(this.key.epub, this.key);
      this.gun.user().get('chats').get(ourSecretChannelId).get('pub').put((await _gun2.default.SEA.encrypt({ pub: pub }, mySecret)));
    }
    if (this.uuid) {
      this.participants[pub] = permissions;
      if (save) {
        this.putDirect('S' + this.uuid, this.getMyGroupSecret());
        this.getMySecretUuid().then(function (s) {
          _this10.putDirect(_this10.uuid, s); // TODO: encrypt keys in put()
        });
        this.onTheirDirect(this.uuid, function (s, k, from) {
          _this10.theirSecretUuids[from] = s;
        });
        this.onTheirDirect('S' + this.uuid, function (s, k, from) {
          _this10.theirGroupSecrets[from] = s;
        });
        this.save();
      }
    }
    if (subscribe) {
      Object.values(this.directSubscriptions).forEach(function (arr) {
        arr.forEach(function (o) {
          if (!o.from || o.from === pub) {
            _this10._onTheirDirectFromUser(pub, o.key, o.callback);
          }
        });
      });
      Object.values(this.groupSubscriptions).forEach(function (arr) {
        arr.forEach(function (o) {
          if (o.from && o.from !== pub) {
            return;
          }
          if (permissions.write) {
            _this10._onTheirGroupFromUser(pub, o.key, o.callback);
          } else {
            // unsubscribe
            o.event && o.event.off();
          }
        });
      });
    }
  };

  /**
  * Send a message to the channel
  * @param msg string or {time, text, ...} object
  */


  Channel.prototype.send = async function send(msg) {
    if (typeof msg === 'string') {
      msg = msg.trim();
      if (msg.length === 0) {
        return;
      }
      msg = {
        time: new Date().toISOString(),
        text: msg
      };
    } else if (typeof msg === 'object') {
      msg.time = msg.time || new Date().toISOString();
    } else {
      throw new Error('msg param must be a string or an object');
    }
    //this.gun.user().get('message').set(temp);
    if (this.uuid) {
      var encrypted = await _gun2.default.SEA.encrypt(JSON.stringify(msg), this.getMyGroupSecret());
      var mySecretUuid = await this.getMySecretUuid();
      this.user.get('chats').get(mySecretUuid).get('msgs').get('' + msg.time).put(encrypted);
      this.user.get('chats').get(mySecretUuid).get('latestMsg').put(encrypted);
    } else {
      var keys = this.getCurrentParticipants();
      for (var i = 0; i < keys.length; i++) {
        var _encrypted = await _gun2.default.SEA.encrypt(JSON.stringify(msg), (await this.getSecret(keys[i])));
        var ourSecretChannelId = await this.getOurSecretChannelId(keys[i]);
        this.user.get('chats').get(ourSecretChannelId).get('msgs').get('' + msg.time).put(_encrypted);
        this.user.get('chats').get(ourSecretChannelId).get('latestMsg').put(_encrypted);
      }
    }
  };

  /**
  * Save the channel to our channels list without sending a message
  */


  Channel.prototype.save = async function save() {
    if (this.uuid) {
      var mySecretUuid = await this.getMySecretUuid();
      this.user.get('chats').get(mySecretUuid).get('msgs').get('a').put(null);
      this.put('participants', this.participants); // public participants list
      var mySecret = await _gun2.default.SEA.secret(this.key.epub, this.key);
      this.user.get('chats').get(mySecretUuid).get('pub').put((await _gun2.default.SEA.encrypt({
        uuid: this.uuid,
        myGroupSecret: this.getMyGroupSecret(),
        participants: this.participants // private participants list
      }, mySecret)));
      this.participantsChanged();
    } else {
      var keys = this.getCurrentParticipants();
      for (var i = 0; i < keys.length; i++) {
        var ourSecretChannelId = await this.getOurSecretChannelId(keys[i]);
        this.user.get('chats').get(ourSecretChannelId).get('msgs').get('a').put(null);
      }
    }
  };

  /**
  * Save a key-value pair, encrypt value. Each participant in the Channel writes to their own version of the key-value pair — they don't overwrite the same one.
  * @param {string} key
  * @param value
  */


  Channel.prototype.put = async function put(key, value) {
    return (this.uuid ? this.putGroup : this.putDirect).call(this, key, value);
  };

  Channel.prototype.putGroup = async function putGroup(key, value) {
    if (key === 'msgs') {
      throw new Error('Sorry, you can\'t overwrite the msgs field which is used for .send()');
    }
    var encrypted = await _gun2.default.SEA.encrypt(JSON.stringify(value), this.getMyGroupSecret());
    var mySecretUuid = await this.getMySecretUuid();
    this.user.get('chats').get(mySecretUuid).get(key).put(encrypted);
  };

  Channel.prototype.putDirect = async function putDirect(key, value) {
    if (key === 'msgs') {
      throw new Error('Sorry, you can\'t overwrite the msgs field which is used for .send()');
    }
    var keys = this.getCurrentParticipants();
    for (var i = 0; i < keys.length; i++) {
      var encrypted = await _gun2.default.SEA.encrypt(JSON.stringify(value), (await this.getSecret(keys[i])));
      var ourSecretChannelId = await this.getOurSecretChannelId(keys[i]);
      this.user.get('chats').get(ourSecretChannelId).get(key).put(encrypted);
    }
  };

  /**
  * Subscribe to a key-value pair. Callback returns every participant's value unless you limit it with *from* param.
  * @param {string} key
  * @param {function} callback
  * @param {string} from public key whose value you want, or *"me"* for your value only, or *"them"* for the value of others only
  */


  Channel.prototype.on = async function on(key, callback, from) {
    return (this.uuid ? this.onGroup : this.onDirect).call(this, key, callback, from);
  };

  Channel.prototype.onDirect = async function onDirect(key, callback, from) {
    var _this11 = this;

    if (!from || from === 'me' || from === this.key.pub) {
      this.onMy(key, function (val) {
        return callback(val, _this11.key.pub);
      });
    }
    if (!from || from !== 'me' && from !== this.key.pub) {
      this.onTheir(key, function (val, k, pub) {
        return callback(val, pub);
      });
    }
  };

  Channel.prototype.onGroup = async function onGroup(key, callback, from) {
    var _this12 = this;

    if (!from || from === 'me' || from === this.key.pub) {
      this.onMyGroup(key, function (val) {
        return callback(val, _this12.key.pub);
      });
    }
    if (!from || from !== 'me' && from !== this.key.pub) {
      this.onTheirGroup(key, function (val, k, pub) {
        return callback(val, pub);
      });
    }
  };

  Channel.prototype.onMy = async function onMy(key, callback) {
    return (this.uuid ? this.onMyGroup : this.onMyDirect).call(this, key, callback);
  };

  Channel.prototype.onMyDirect = async function onMyDirect(key, callback) {
    var _this13 = this;

    if (typeof callback !== 'function') {
      throw new Error('onMy callback must be a function, got ' + (typeof callback === 'undefined' ? 'undefined' : _typeof(callback)));
    }
    var keys = this.getCurrentParticipants();

    var _loop = async function _loop(i) {
      var ourSecretChannelId = await _this13.getOurSecretChannelId(keys[i]);
      _this13.gun.user().get('chats').get(ourSecretChannelId).get(key).on(async function (data) {
        var decrypted = await _gun2.default.SEA.decrypt(data, (await _this13.getSecret(keys[i])));
        if (decrypted) {
          callback(typeof decrypted.v !== 'undefined' ? decrypted.v : decrypted, key);
        }
      });
      return 'break';
    };

    for (var i = 0; i < keys.length; i++) {
      var _ret = await _loop(i);

      if (_ret === 'break') break;
    }
  };

  Channel.prototype.onMyGroup = async function onMyGroup(key, callback) {
    var _this14 = this;

    if (typeof callback !== 'function') {
      throw new Error('onMy callback must be a function, got ' + (typeof callback === 'undefined' ? 'undefined' : _typeof(callback)));
    }
    var mySecretUuid = await this.getMySecretUuid();
    var mySecret = await this.getMyGroupSecret();
    this.gun.user().get('chats').get(mySecretUuid).get(key).on(async function (data) {
      var decrypted = await _gun2.default.SEA.decrypt(data, mySecret);
      if (decrypted) {
        callback(typeof decrypted.v !== 'undefined' ? decrypted.v : decrypted, key, _this14.key.pub);
      }
    });
  };

  Channel.prototype.onTheir = async function onTheir(key, callback, from) {
    return (this.uuid ? this.onTheirGroup : this.onTheirDirect).call(this, key, callback, from);
  };

  Channel.prototype._onTheirDirectFromUser = async function _onTheirDirectFromUser(pub, key, callback) {
    var _this15 = this;

    if (!this.hasWritePermission(pub)) {
      return;
    }
    var theirSecretChannelId = await this.getTheirSecretChannelId(pub);
    this.gun.user(pub).get('chats').get(theirSecretChannelId).get(key).on(async function (data) {
      if (!_this15.hasWritePermission(pub)) {
        return;
      }
      var decrypted = await _gun2.default.SEA.decrypt(data, (await _this15.getSecret(pub)));
      if (decrypted) {
        callback(typeof decrypted.v !== 'undefined' ? decrypted.v : decrypted, key, pub);
      }
    });
  };

  Channel.prototype.onTheirDirect = async function onTheirDirect(key, callback, from) {
    var _this16 = this;

    // TODO: subscribe to new channel participants
    if (typeof callback !== 'function') {
      throw new Error('onTheir callback must be a function, got ' + (typeof callback === 'undefined' ? 'undefined' : _typeof(callback)));
    }
    if (!this.directSubscriptions.hasOwnProperty(key)) {
      this.directSubscriptions[key] = [];
    }
    this.directSubscriptions[key].push({ key: key, callback: callback, from: from });
    var participants = this.getCurrentParticipants();
    participants.forEach(async function (pub) {
      if (from && pub !== from) {
        return;
      }
      _this16._onTheirDirectFromUser(pub, key, callback);
    });
  };

  Channel.prototype.hasWritePermission = function hasWritePermission(pub) {
    return !this.uuid || this.participants && this.participants[pub] && this.participants[pub].write;
  };

  Channel.prototype._onTheirGroupFromUser = async function _onTheirGroupFromUser(pub, key, callback, subscription) {
    var _this17 = this;

    if (!this.hasWritePermission(pub)) {
      return;
    }
    var theirSecretUuid = await this.getTheirSecretUuid(pub);
    this.gun.user(pub).get('chats').get(theirSecretUuid).get(key).on(async function (data, a, b, e) {
      if (subscription) {
        subscription.event = e;
      }
      if (!_this17.hasWritePermission(pub)) {
        return;
      }
      var decrypted = await _gun2.default.SEA.decrypt(data, (await _this17.getTheirGroupSecret(pub)));
      if (decrypted) {
        callback(typeof decrypted.v !== 'undefined' ? decrypted.v : decrypted, key, pub);
      }
    });
  };

  Channel.prototype.onTheirGroup = async function onTheirGroup(key, callback, from) {
    var _this18 = this;

    if (typeof callback !== 'function') {
      throw new Error('onTheir callback must be a function, got ' + (typeof callback === 'undefined' ? 'undefined' : _typeof(callback)));
    }
    if (!this.groupSubscriptions.hasOwnProperty(key)) {
      this.groupSubscriptions[key] = [];
    }
    var subscription = { key: key, callback: callback, from: from };
    this.groupSubscriptions[key].push(subscription);

    this.getParticipants(function (participants) {
      Object.keys(participants).forEach(async function (pub) {
        if (from && pub !== from) {
          return;
        }
        if (!(participants[pub] && participants[pub].write)) {
          return;
        }
        _this18._onTheirGroupFromUser(pub, key, callback, subscription);
      });
    });
  };

  /**
  * Set typing status
  */


  Channel.prototype.setTyping = function setTyping(isTyping) {
    var _this19 = this;

    var timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;

    isTyping = typeof isTyping === 'undefined' ? true : isTyping;
    timeout = timeout * 1000;
    this.put('typing', isTyping ? new Date().toISOString() : new Date(0).toISOString());
    clearTimeout(this.setTypingTimeout);
    this.setTypingTimeout = setTimeout(function () {
      return _this19.put('typing', false);
    }, timeout);
  };

  /**
  * Get typing status
  */


  Channel.prototype.getTyping = function getTyping(callback) {
    var _this20 = this;

    var timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;
    // TODO callback not called on setTyping(false), at least for self chat
    timeout = timeout * 1000;
    this.onTheir('typing', function (typing, key, pub) {
      if (callback) {
        var isTyping = typing && new Date() - new Date(typing) <= timeout;
        callback(isTyping, pub);
        _this20.getTypingTimeouts = _this20.getTypingTimeouts || {};
        clearTimeout(_this20.getTypingTimeouts[pub]);
        if (isTyping) {
          _this20.getTypingTimeouts[pub] = setTimeout(function () {
            return callback(false, pub);
          }, timeout);
        }
      }
    });
  };

  /**
  * Add a chat button to page
  * @param options {label, channelOptions}
  */


  Channel.addChatButton = function addChatButton() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    options = Object.assign({ label: 'Chat' }, options);
    if (!options.channelOptions) {
      throw new Error('addChatButton missing options.channelOptions param');
    }
    _util2.default.injectCss();
    var channel = void 0,
        box = void 0;
    var btn = _util2.default.createElement('div', 'iris-chat-open-button', document.body);
    btn.setAttribute('id', 'iris-chat-open-button');
    btn.innerHTML = '<svg style="margin-right:7px;margin-bottom: -0.2em" version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 510 510" xml:space="preserve"><path fill="currentColor" d="M459,0H51C22.95,0,0,22.95,0,51v459l102-102h357c28.05,0,51-22.95,51-51V51C510,22.95,487.05,0,459,0z M102,178.5h306v51 H102V178.5z M306,306H102v-51h204V306z M408,153H102v-51h306V153z"></path></svg> ' + options.label;
    btn.addEventListener('click', function () {
      btn.setAttribute('style', 'display: none');
      if (!channel) {
        channel = new Channel(options.channelOptions);
        box = channel.getChatBox();
        document.body.appendChild(box);
      } else {
        box.setAttribute('style', ''); // show
      }
    });
  };

  /**
  * Get a simple link that points to the channel.
  *
  * Direct channel: both users need to give their simple links. Use createChatLink() to get a two-way link that needs to be given by one user only.
  *
  * Group channel: Works only if the link recipient has been already added onto the channel participants list.
  */


  Channel.prototype.getSimpleLink = function getSimpleLink() {
    var urlRoot = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'https://iris.to/';

    if (this.uuid) {
      return urlRoot + '?channelId=' + this.uuid + '&inviter=' + this.key.pub;
    } else {
      return urlRoot + '?chatWith=' + this.getCurrentParticipants()[0];
    }
  };

  /**
  *
  */


  Channel.prototype.getChatLinks = async function getChatLinks(_ref) {
    var _this21 = this;

    var callback = _ref.callback,
        urlRoot = _ref.urlRoot,
        subscribe = _ref.subscribe;

    urlRoot = urlRoot || 'https://iris.to/';
    if (!this.uuid) {
      throw new Error('Only group channels may have chat links');
    }
    var chatLinks = [];
    var chatLinkSubscriptions = {};
    this.on('chatLinks', function (links, from) {
      // TODO: check admin permissions
      if (!links || (typeof links === 'undefined' ? 'undefined' : _typeof(links)) !== 'object') {
        return;
      }
      Object.keys(links).forEach(function (linkId) {
        var link = links[linkId];
        if (link === null) {
          chatLinkSubscriptions[linkId] && chatLinkSubscriptions[linkId].off(); // unsubscribe removed chat link
          delete chatLinkSubscriptions[linkId];
          callback && callback({ id: linkId, url: null });
          return;
        }
        if (chatLinks.indexOf(linkId) !== -1) {
          return;
        }
        var channels = [];
        chatLinks.push(linkId);
        var url = Channel.formatChatLink({ urlRoot: urlRoot, inviter: from, channelId: _this21.uuid, sharedSecret: link.sharedSecret, linkId: linkId });
        callback && callback({ url: url, id: linkId });
        if (subscribe) {
          _this21.gun.user(link.sharedKey.pub).get('chatRequests').map().on(async function (encPub, requestId, a, e) {
            if (!encPub || typeof encPub !== 'string' || encPub.length < 10) {
              return;
            }
            chatLinkSubscriptions[linkId] = e;
            var s = JSON.stringify(encPub);
            if (channels.indexOf(s) === -1) {
              channels.push(s);
              var pub = await _gun2.default.SEA.decrypt(encPub, link.sharedSecret);
              _this21.addParticipant(pub, undefined, undefined, true);
            }
          });
        }
      });
    });
  };

  Channel.prototype.createChatLink = async function createChatLink() {
    var urlRoot = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'https://iris.to/';

    var sharedKey = await _gun2.default.SEA.pair();
    var sharedKeyString = JSON.stringify(sharedKey);
    var sharedSecret = await _gun2.default.SEA.secret(sharedKey.epub, sharedKey);
    var encryptedSharedKey = await _gun2.default.SEA.encrypt(sharedKeyString, sharedSecret);
    var ownerSecret = await _gun2.default.SEA.secret(this.key.epub, this.key);
    var ownerEncryptedSharedKey = await _gun2.default.SEA.encrypt(sharedKeyString, ownerSecret);
    var linkId = await _util2.default.getHash(encryptedSharedKey);
    linkId = linkId.slice(0, 12);

    // User has to exist, in order for .get(chatRequests).on() to be ever triggered
    await _util2.default.gunAsAnotherUser(this.gun, sharedKey, function (user) {
      return user.get('chatRequests').put({ a: 1 }).then();
    });

    this.chatLinks[linkId] = { sharedKey: sharedKey, sharedSecret: sharedSecret };
    this.put('chatLinks', this.chatLinks);
    this.user.get('chatLinks').get(linkId).put({ encryptedSharedKey: encryptedSharedKey, ownerEncryptedSharedKey: ownerEncryptedSharedKey });

    return Channel.formatChatLink({ urlRoot: urlRoot, channelId: this.uuid, inviter: this.key.pub, sharedSecret: sharedSecret, linkId: linkId });
  };

  /**
  * Get a channel box element that you can add to your page
  */


  Channel.prototype.getChatBox = function getChatBox() {
    var _this22 = this;

    _util2.default.injectCss();
    var minimized = false;

    var chatBox = _util2.default.createElement('div', 'iris-chat-box');
    var header = _util2.default.createElement('div', 'iris-chat-header', chatBox);
    var minimize = _util2.default.createElement('span', 'iris-chat-minimize', header);
    minimize.innerText = '—';
    minimize.addEventListener('click', function (e) {
      e.stopPropagation();
      chatBox.setAttribute('class', 'iris-chat-box minimized');
      minimized = true;
    });
    var headerText = _util2.default.createElement('div', 'iris-chat-header-text', header);
    var onlineIndicator = _util2.default.createElement('span', 'iris-online-indicator', headerText);
    onlineIndicator.innerHTML = '&#x25cf;';
    var nameEl = _util2.default.createElement('span', undefined, headerText);
    var close = _util2.default.createElement('span', 'iris-chat-close', header);
    close.innerHTML = '&#215;';
    close.addEventListener('click', function () {
      chatBox.setAttribute('style', 'display: none');
      var openChatBtn = document.getElementById('iris-chat-open-button');
      if (openChatBtn) {
        openChatBtn.setAttribute('style', ''); // show
      }
    });
    header.addEventListener('click', function () {
      if (minimized) {
        chatBox.setAttribute('class', 'iris-chat-box');
        minimized = false;
      }
    });

    var messages = _util2.default.createElement('div', 'iris-chat-messages', chatBox);

    var typingIndicator = _util2.default.createElement('div', 'iris-typing-indicator', chatBox);
    typingIndicator.innerText = 'typing...';
    this.getTyping(function (isTyping) {
      typingIndicator.setAttribute('class', 'iris-typing-indicator' + (isTyping ? ' yes' : ''));
    });

    var inputWrapper = _util2.default.createElement('div', 'iris-chat-input-wrapper', chatBox);
    var textArea = _util2.default.createElement('textarea', undefined, inputWrapper);
    textArea.setAttribute('rows', '1');
    textArea.setAttribute('placeholder', 'Type a message');
    if (_util2.default.isMobile) {
      var sendBtn = _util2.default.createElement('button', undefined, inputWrapper);
      sendBtn.innerHTML = '\n        <svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 486.736 486.736" style="enable-background:new 0 0 486.736 486.736;" xml:space="preserve" width="100px" height="100px" fill="#000000" stroke="#000000" stroke-width="0"><path fill="currentColor" d="M481.883,61.238l-474.3,171.4c-8.8,3.2-10.3,15-2.6,20.2l70.9,48.4l321.8-169.7l-272.4,203.4v82.4c0,5.6,6.3,9,11,5.9 l60-39.8l59.1,40.3c5.4,3.7,12.8,2.1,16.3-3.5l214.5-353.7C487.983,63.638,485.083,60.038,481.883,61.238z"></path></svg>\n      ';
      sendBtn.addEventListener('click', function () {
        _this22.send(textArea.value);
        textArea.value = '';
        _this22.setTyping(false);
      });
    }

    var participants = this.getCurrentParticipants();
    if (participants.length) {
      var pub = participants[0];
      this.gun.user(pub).get('profile').get('name').on(function (name) {
        return nameEl.innerText = name;
      });
      Channel.getActivity(this.gun, pub, function (status) {
        var cls = 'iris-online-indicator' + (status.isActive ? ' yes' : '');
        onlineIndicator.setAttribute('class', cls);
        var undelivered = messages.querySelectorAll('.iris-chat-message:not(.delivered)');
        undelivered.forEach(function (msg) {
          if (msg.getAttribute('data-time') <= status.lastActive) {
            var c = msg.getAttribute('class');
            msg.setAttribute('class', c + ' delivered');
          }
        });
      });
    }

    this.getTheirMsgsLastSeenTime(function (time) {
      var unseen = messages.querySelectorAll('.iris-seen:not(.yes)');
      unseen.forEach(function (indicator) {
        var msgEl = indicator.parentElement.parentElement.parentElement;
        if (msgEl.getAttribute('data-time') <= time) {
          var msgClass = msgEl.getAttribute('class');
          if (msgClass.indexOf('delivered') === -1) {
            msgEl.setAttribute('class', msgClass + ' delivered');
          }
          indicator.setAttribute('class', 'iris-seen yes');
        }
      });
    });

    this.getMessages(function (msg, info) {
      var msgContent = _util2.default.createElement('div', 'iris-msg-content');
      msgContent.innerText = msg.text;
      var time = _util2.default.createElement('div', 'time', msgContent);
      time.innerText = _util2.default.formatTime(new Date(msg.time));
      if (info.selfAuthored) {
        var cls = _this22.theirMsgsLastSeenTime >= msg.time ? 'iris-seen yes' : 'iris-seen';
        var seenIndicator = _util2.default.createElement('span', cls, time);
        seenIndicator.innerHTML = ' <svg version="1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 59 42"><polygon fill="currentColor" points="40.6,12.1 17,35.7 7.4,26.1 4.6,29 17,41.3 43.4,14.9"></polygon><polygon class="iris-delivered-checkmark" fill="currentColor" points="55.6,12.1 32,35.7 29.4,33.1 26.6,36 32,41.3 58.4,14.9"></polygon></svg>';
      }
      msgContent.innerHTML = msgContent.innerHTML.replace(/\n/g, '<br>\n');

      var msgEl = _util2.default.createElement('div', (info.selfAuthored ? 'our' : 'their') + ' iris-chat-message');
      msgEl.appendChild(msgContent);
      msgEl.setAttribute('data-time', msg.time);
      for (var i = messages.children.length; i >= 0; i--) {
        if (i === 0) {
          messages.insertBefore(msgEl, messages.firstChild);
        } else {
          var t = messages.children[i - 1].getAttribute('data-time');
          if (t && t < msg.time) {
            messages.children[i - 1].insertAdjacentElement('afterend', msgEl);
            break;
          }
        }
      }
      messages.scrollTop = messages.scrollHeight;
    });

    textArea.addEventListener('keyup', function (event) {
      Channel.setActivity(_this22.gun, true); // TODO
      _this22.setMyMsgsLastSeenTime(); // TODO
      if (event.keyCode === 13) {
        event.preventDefault();
        var content = textArea.value;
        var caret = _util2.default.getCaret(textArea);
        if (event.shiftKey) {
          textArea.value = content.substring(0, caret - 1) + '\n' + content.substring(caret, content.length);
        } else {
          textArea.value = content.substring(0, caret - 1) + content.substring(caret, content.length);
          _this22.send(textArea.value);
          textArea.value = '';
          _this22.setTyping(false);
        }
      } else {
        _this22.setTyping(!!textArea.value.length);
      }
    });

    return chatBox;
  };

  /**
  * Set the user's online/active status
  * @param {object} gun
  * @param {string} activity string: set the activity status every 3 seconds, null/false: stop updating
  */


  Channel.setActivity = function setActivity(gun, activity) {
    if (gun.irisActivityStatus === activity) {
      return;
    }
    gun.irisActivityStatus = activity;
    clearTimeout(gun.setActivityTimeout);
    var update = function update() {
      gun.user().get('activity').put({ status: activity, time: new Date(_gun2.default.state()).toISOString() });
    };
    update();
    function timerUpdate() {
      update();
      gun.setActivityTimeout = setTimeout(timerUpdate, 3000);
    }
    if (activity) {
      timerUpdate();
    }
  };

  /**
  * Get the online status of a user.
  *
  * @param {object} gun
  * @param {string} pubKey public key of the user
  * @param {boolean} callback receives a boolean each time the user's online status changes
  */


  Channel.getActivity = function getActivity(gun, pubKey, callback) {
    var timeout = void 0;
    gun.user(pubKey).get('activity').on(function (activity) {
      if (!activity || !(activity.time && activity.status)) {
        return;
      }
      clearTimeout(timeout);
      var now = new Date(_gun2.default.state());
      var activityDate = new Date(activity.time);
      var isActive = activityDate > new Date(now.getTime() - 10 * 1000) && activityDate < new Date(now.getTime() + 30 * 1000);
      callback({ isActive: isActive, lastActive: activity.time, status: activity.status });
      if (isActive) {
        timeout = setTimeout(function () {
          return callback({ isOnline: false, lastActive: activity.time });
        }, 10000);
      }
    });
  };

  /**
  * In order to receive messages from others, this method must be called for newly created
  * users that have not started a channel with an existing user yet.
  *
  * It saves the user's key.epub (public key for encryption) into their gun user space,
  * so others can find it and write encrypted messages to them.
  *
  * If you start a channel with an existing user, key.epub is saved automatically and you don't need
  * to call this method.
  */


  Channel.initUser = function initUser(gun, key) {
    var user = gun.user();
    user.auth(key);
    user.put({ epub: key.epub });
  };

  Channel.formatChatLink = function formatChatLink(_ref2) {
    var urlRoot = _ref2.urlRoot,
        chatWith = _ref2.chatWith,
        channelId = _ref2.channelId,
        inviter = _ref2.inviter,
        sharedSecret = _ref2.sharedSecret,
        linkId = _ref2.linkId;

    var enc = encodeURIComponent;
    if (channelId && inviter) {
      return urlRoot + '?channelId=' + enc(channelId) + '&inviter=' + enc(inviter) + '&s=' + enc(sharedSecret) + '&k=' + enc(linkId);
    } else {
      return urlRoot + '?chatWith=' + enc(chatWith) + '&s=' + enc(sharedSecret) + '&k=' + enc(linkId);
    }
  };

  /**
  * Creates a channel link that can be used for two-way communication, i.e. only one link needs to be exchanged.
  */


  Channel.createChatLink = async function createChatLink(gun, key) {
    var urlRoot = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'https://iris.to/';

    var user = gun.user();
    user.auth(key);

    var sharedKey = await _gun2.default.SEA.pair();
    var sharedKeyString = JSON.stringify(sharedKey);
    var sharedSecret = await _gun2.default.SEA.secret(sharedKey.epub, sharedKey);
    var encryptedSharedKey = await _gun2.default.SEA.encrypt(sharedKeyString, sharedSecret);
    var ownerSecret = await _gun2.default.SEA.secret(key.epub, key);
    var ownerEncryptedSharedKey = await _gun2.default.SEA.encrypt(sharedKeyString, ownerSecret);
    var linkId = await _util2.default.getHash(encryptedSharedKey);
    linkId = linkId.slice(0, 12);

    // User has to exist, in order for .get(chatRequests).on() to be ever triggered
    await _util2.default.gunAsAnotherUser(gun, sharedKey, function (user) {
      return user.get('chatRequests').put({ a: 1 }).then();
    });

    user.get('chatLinks').get(linkId).put({ encryptedSharedKey: encryptedSharedKey, ownerEncryptedSharedKey: ownerEncryptedSharedKey });

    return Channel.formatChatLink({ urlRoot: urlRoot, chatWith: key.pub, sharedSecret: sharedSecret, linkId: linkId });
  };

  /**
  *
  */


  Channel.getMyChatLinks = async function getMyChatLinks(gun, key) {
    var urlRoot = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'https://iris.to/';
    var callback = arguments[3];
    var subscribe = arguments[4];

    var user = gun.user();
    user.auth(key);
    var mySecret = await _gun2.default.SEA.secret(key.epub, key);
    var chatLinks = [];
    user.get('chatLinks').map().on(function (data, linkId) {
      if (!data || chatLinks.indexOf(linkId) !== -1) {
        return;
      }
      var channels = [];
      user.get('chatLinks').get(linkId).get('ownerEncryptedSharedKey').on(async function (enc) {
        if (!enc || chatLinks.indexOf(linkId) !== -1) {
          return;
        }
        chatLinks.push(linkId);
        var sharedKey = await _gun2.default.SEA.decrypt(enc, mySecret);
        var sharedSecret = await _gun2.default.SEA.secret(sharedKey.epub, sharedKey);
        var url = Channel.formatChatLink({ urlRoot: urlRoot, chatWith: key.pub, sharedSecret: sharedSecret, linkId: linkId });
        if (callback) {
          callback({ url: url, id: linkId });
        }
        if (subscribe) {
          gun.user(sharedKey.pub).get('chatRequests').map().on(async function (encPub, requestId) {
            if (!encPub) {
              return;
            }
            var s = JSON.stringify(encPub);
            if (channels.indexOf(s) === -1) {
              channels.push(s);
              var pub = await _gun2.default.SEA.decrypt(encPub, sharedSecret);
              var channel = new Channel({ gun: gun, key: key, participants: pub });
              channel.save();
            }
            _util2.default.gunAsAnotherUser(gun, sharedKey, function (user) {
              // remove the channel request after reading
              user.get('chatRequests').get(requestId).put(null);
            });
          });
        }
      });
    });
  };

  /**
  *
  */


  Channel.prototype.removeGroupChatLink = function removeGroupChatLink(linkId) {
    this.chatLinks[linkId] = null;
    this.put('chatLinks', this.chatLinks);
    this.gun.user().get('chatLinks').get(linkId).put(null);
  };

  /**
  *
  */


  Channel.removePrivateChatLink = function removePrivateChatLink(gun, key, linkId) {
    gun.user().auth(key);
    gun.user().get('chatLinks').get(linkId).put(null);
  };

  /**
  *
  */


  Channel.deleteChannel = async function deleteChannel(gun, key, pub) {
    gun.user().auth(key);
    var channelId = await Channel.getOurSecretChannelId(gun, pub, key);
    gun.user().get('channels').get(channelId).put(null);
    gun.user().get('channels').get(channelId).off();
  };

  return Channel;
}();

exports.default = Channel;
module.exports = exports['default'];