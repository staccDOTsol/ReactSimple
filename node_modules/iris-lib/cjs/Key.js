'use strict';

exports.__esModule = true;

var _util = require('./util');

var _util2 = _interopRequireDefault(_util);

var _gun = require('gun');

var _gun2 = _interopRequireDefault(_gun);

require('gun/sea');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /*eslint no-useless-escape: "off", camelcase: "off" */

// eslint-disable-line no-unused-vars


// eslint-disable-line no-unused-vars

var myKey = void 0;

/**
* Key management utils. Wraps GUN's Gun.SEA. https://gun.eco/docs/Gun.SEA
*/

var Key = function () {
  function Key() {
    _classCallCheck(this, Key);
  }

  /**
  * Load private key from datadir/iris.key on node.js or from local storage 'iris.myKey' in browser.
  *
  * If the key does not exist, it is generated.
  * @param {string} datadir directory to find key from. In browser, localStorage is used instead.
  * @param {string} keyfile keyfile name (within datadir)
  * @param {Object} fs node: require('fs'); browser: leave empty.
  * @returns {Promise<Object>} keypair object
  */
  Key.getActiveKey = async function getActiveKey() {
    var datadir = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '.';
    var keyfile = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'iris.key';
    var fs = arguments[2];

    if (myKey) {
      return myKey;
    }
    if (fs) {
      var privKeyFile = datadir + '/' + keyfile;
      if (fs.existsSync(privKeyFile)) {
        var f = fs.readFileSync(privKeyFile, 'utf8');
        myKey = Key.fromString(f);
      } else {
        var newKey = await Key.generate();
        myKey = myKey || newKey; // eslint-disable-line require-atomic-updates
        fs.writeFileSync(privKeyFile, Key.toString(myKey));
        fs.chmodSync(privKeyFile, 400);
      }
      if (!myKey) {
        throw new Error('loading default key failed - check ' + datadir + '/' + keyfile);
      }
    } else {
      var str = window.localStorage.getItem('iris.myKey');
      if (str) {
        myKey = Key.fromString(str);
      } else {
        var _newKey = await Key.generate();
        myKey = myKey || _newKey; // eslint-disable-line require-atomic-updates
        window.localStorage.setItem('iris.myKey', Key.toString(myKey));
      }
      if (!myKey) {
        throw new Error('loading default key failed - check localStorage iris.myKey');
      }
    }
    return myKey;
  };

  Key.getDefault = function getDefault() {
    var datadir = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '.';
    var keyfile = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'iris.key';

    return Key.getActiveKey(datadir, keyfile);
  };

  Key.getActivePub = async function getActivePub() {
    var datadir = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '.';
    var keyfile = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'iris.key';

    var key = await Key.getActiveKey(datadir, keyfile);
    return key.pub;
  };

  /**
  *
  */


  Key.setActiveKey = function setActiveKey(key) {
    var save = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    var datadir = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '.';
    var keyfile = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'iris.key';
    var fs = arguments[4];

    myKey = key;
    if (!save) return;
    if (_util2.default.isNode) {
      var privKeyFile = datadir + '/' + keyfile;
      fs.writeFileSync(privKeyFile, Key.toString(myKey));
      fs.chmodSync(privKeyFile, 400);
    } else {
      window.localStorage.setItem('iris.myKey', Key.toString(myKey));
    }
  };

  /**
  * Serialize key as JSON string
  * @param {Object} key key to serialize
  * @returns {String} JSON Web Key string
  */


  Key.toString = function toString(key) {
    return JSON.stringify(key);
  };

  /**
  * Get keyID
  * @param {Object} key key to get an id for. Currently just returns the public key string.
  * @returns {String} public key string
  */


  Key.getId = function getId(key) {
    if (!(key && key.pub)) {
      throw new Error('missing param');
    }
    return key.pub; // hack until GUN supports lookups by keyID
    //return util.getHash(key.pub);
  };

  /**
  * Get a keypair from a JSON string.
  * @param {String} str key JSON
  * @returns {Object} Gun.SEA keypair object
  */


  Key.fromString = function fromString(str) {
    return JSON.parse(str);
  };

  /**
  * Generate a new keypair
  * @returns {Promise<Object>} Gun.SEA keypair object
  */


  Key.generate = function generate() {
    return _gun2.default.SEA.pair();
  };

  /**
  * Sign a message
  * @param {String} msg message to sign
  * @param {Object} pair signing keypair
  * @returns {Promise<String>} signed message string
  */


  Key.sign = async function sign(msg, pair) {
    var sig = await _gun2.default.SEA.sign(msg, pair);
    return 'a' + sig;
  };

  /**
  * Verify a signed message
  * @param {String} msg message to verify
  * @param {Object} pubKey public key of the signer
  * @returns {Promise<String>} signature string
  */


  Key.verify = function verify(msg, pubKey) {
    return _gun2.default.SEA.verify(msg.slice(1), pubKey);
  };

  return Key;
}();

exports.default = Key;
module.exports = exports['default'];