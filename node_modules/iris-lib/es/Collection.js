function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

import Gun from 'gun'; // eslint-disable-line no-unused-vars
// eslint-disable-line no-unused-vars

/**
* Gun object collection that provides tools for indexing and search. Decentralize everything!
*
* If opt.class is passed, object.serialize() and opt.class.deserialize() must be defined.
*
* Supports search from multiple indexes.
* For example, retrieve message feed from your own index and your friends' indexes.
*
* TODO: aggregation
* TODO: example
* TODO: scrollable and stretchable "search result window"
* @param {Object} opt {gun, class, indexes = [], askPeers = true, name = class.name}
*/

var Collection = function () {
  function Collection() {
    var opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Collection);

    if (!opt.gun) {
      throw new Error('Missing opt.gun');
    }
    if (!(opt.class || opt.name)) {
      throw new Error('You must supply either opt.name or opt.class');
    }
    this.class = opt.class;
    this.serializer = opt.serializer;
    if (this.class && !this.class.deserialize && !this.serializer) {
      throw new Error('opt.class must have deserialize() method or opt.serializer must be defined');
    }
    this.name = opt.name || opt.class.name;
    this.gun = opt.gun;
    this.indexes = opt.indexes || [];
    this.indexer = opt.indexer;
    this.askPeers = typeof opt.askPeers === 'undefined' ? true : opt.askPeers;
  }

  /**
  * @return {String} id of added object, which can be used for collection.get(id)
  */


  Collection.prototype.put = function put(object) {
    var opt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var data = object;
    if (this.serializer) {
      data = this.serializer.serialize(object);
    }if (this.class) {
      data = object.serialize();
    }
    // TODO: optionally use gun hash table
    var node = void 0;
    if (opt.id || data.id) {
      node = this.gun.get(this.name).get('id').get(opt.id || data.id).put(data); // TODO: use .top()
    } else if (object.getId) {
      node = this.gun.get(this.name).get('id').get(object.getId()).put(data);
    } else {
      node = this.gun.get(this.name).get('id').set(data);
    }
    this._addToIndexes(data, node);
    return data.id || Gun.node.soul(node) || node._.link;
  };

  Collection.prototype._addToIndexes = async function _addToIndexes(serializedObject, node) {
    var _this = this;

    if (Gun.node.is(serializedObject)) {
      serializedObject = await serializedObject.open();
    }
    var addToIndex = function addToIndex(indexName, indexKey) {
      _this.gun.get(_this.name).get(indexName).get(indexKey).put(node);
    };
    if (this.indexer) {
      var customIndexes = await this.indexer(serializedObject);
      var customIndexKeys = Object.keys(customIndexes);
      for (var i = 0; i < customIndexKeys; i++) {
        var key = customIndexKeys[i];
        addToIndex(key, customIndexes[key]);
      }
    }
    for (var _i = 0; _i < this.indexes.length; _i++) {
      var indexName = this.indexes[_i];
      if (Object.prototype.hasOwnProperty.call(serializedObject, indexName)) {
        addToIndex(indexName, serializedObject[indexName]);
      }
    }
  };

  // TODO: method for terminating the query
  // TODO: query ttl. https://mongodb.github.io/node-mongodb-native/2.0/api/Collection.html
  /**
  * @param {Object} opt {callback, id, selector, limit, orderBy}
  */


  Collection.prototype.get = function get() {
    var _this2 = this;

    var opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    if (!opt.callback) {
      return;
    }
    var results = 0;
    var matcher = function matcher(data, id, node) {
      if (!data) {
        return;
      }
      if (opt.limit && results++ >= opt.limit) {
        return; // TODO: terminate query
      }
      if (opt.selector) {
        // TODO: deep compare selector object?
        var keys = Object.keys(opt.selector);
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          if (!Object.prototype.hasOwnProperty.call(data, key)) {
            return;
          }
          var v1 = void 0,
              v2 = void 0;
          if (opt.caseSensitive === false) {
            v1 = data[key].toLowerCase();
            v2 = opt.selector[key].toLowerCase();
          } else {
            v1 = data[key];
            v2 = opt.selector[key];
          }
          if (v1 !== v2) {
            return;
          }
        }
      }
      if (opt.query) {
        // TODO: use gun.get() lt / gt operators
        var _keys = Object.keys(opt.query);
        for (var _i2 = 0; _i2 < _keys.length; _i2++) {
          var _key = _keys[_i2];
          if (!Object.prototype.hasOwnProperty.call(data, _key)) {
            return;
          }
          var _v = void 0,
              _v2 = void 0;
          if (opt.caseSensitive === false) {
            _v = data[_key].toLowerCase();
            _v2 = opt.query[_key].toLowerCase();
          } else {
            _v = data[_key];
            _v2 = opt.query[_key];
          }
          if (_v.indexOf(_v2) !== 0) {
            return;
          }
        }
      }
      if (_this2.serializer) {
        opt.callback(_this2.serializer.deserialize(data, { id: id, gun: node.$ }));
      } else if (_this2.class) {
        opt.callback(_this2.class.deserialize(data, { id: id, gun: node.$ }));
      } else {
        opt.callback(data);
      }
    };

    if (opt.id) {
      opt.limit = 1;
      this.gun.get(this.name).get('id').get(opt.id).on(matcher);
      return;
    }

    var indexName = 'id';
    if (opt.orderBy && this.indexes.indexOf(opt.orderBy) > -1) {
      indexName = opt.orderBy;
    }

    // TODO: query from indexes
    this.gun.get(this.name).get(indexName).map().on(matcher); // TODO: limit .open recursion
    if (this.askPeers) {
      this.gun.get('trustedIndexes').on(function (val, key) {
        _this2.gun.user(key).get(_this2.name).get(indexName).map().on(matcher);
      });
    }
  };

  Collection.prototype.delete = function _delete() {
    // gun.unset()
  };

  return Collection;
}();

export default Collection;