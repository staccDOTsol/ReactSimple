var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/*jshint unused: false */
'use strict';
import util from './util';
import Attribute from './Attribute';
import Key from './Key';

var errorMsg = 'Invalid  message:';

var ValidationError = function (_Error) {
  _inherits(ValidationError, _Error);

  function ValidationError() {
    _classCallCheck(this, ValidationError);

    return _possibleConstructorReturn(this, _Error.apply(this, arguments));
  }

  return ValidationError;
}(Error);

/**
* Signed message object. Your friends can index and relay your messages, while others can still verify that they were signed by you.
*
* Fields: signedData, signer (public key) and signature.
*
* signedData has an author, signer, type, time and optionally other fields.
*
* signature covers the utf8 string representation of signedData. Since messages are digitally signed, users only need to care about the message signer and not who relayed it or whose index it was found from.
*
* signer is the entity that verified its origin. In other words: message author and signer can be different entities, and only the signer needs to use Iris.
*
* For example, a crawler can import and sign other people's messages from Twitter. Only the users who trust the crawler will see the messages.
*
* "Rating" type messages, when added to an SocialNetwork, can add or remove Identities from the web of trust. Verification/unverification messages can add or remove Attributes from an Contact. Other types of messages such as social media "post" are just indexed by their author, recipient and time.
*
* Constructor: creates a message from the param obj.signedData that must contain at least the mandatory fields: author, recipient, type and time. You can use createRating() and createVerification() to automatically populate some of these fields and optionally sign the message.
* @param obj
*
* @example
* https://github.com/irislib/iris-lib/blob/master/__tests__/SignedMessage.js
*
* Rating message:
* {
*   signedData: {
*     author: {name:'Alice', key:'ABCD1234'},
*     recipient: {name:'Bob', email:'bob@example.com'},
*     type: 'rating',
*     rating: 1,
*     maxRating: 10,
*     minRating: -10,
*     text: 'Traded 1 BTC'
*   },
*   signer: 'ABCD1234',
*   signature: '1234ABCD'
* }
*
* Verification message:
* {
*   signedData: {
*     author: {name:'Alice', key:'ABCD1234'},
*     recipient: {
*       name: 'Bob',
*       email: ['bob@example.com', 'bob.saget@example.com'],
*       bitcoin: '1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa'
*     },
*     type: 'verification'
*   },
*   signer: 'ABCD1234',
*   signature: '1234ABCD'
* }
*/


var SignedMessage = function () {
  function SignedMessage(obj) {
    _classCallCheck(this, SignedMessage);

    if (obj.signedData) {
      this.signedData = obj.signedData;
    }
    if (obj.pubKey) {
      this.pubKey = obj.pubKey;
    }
    if (obj.sig) {
      if (typeof obj.sig !== 'string') {
        throw new ValidationError('SignedMessage signature must be a string');
      }
      this.sig = obj.sig;
      this.getHash();
    }
    this._validate();
  }

  SignedMessage._getArray = function _getArray(authorOrRecipient) {
    var arr = [];
    var keys = Object.keys(authorOrRecipient);
    for (var i = 0; i < keys.length; i++) {
      var type = keys[i];
      var value = authorOrRecipient[keys[i]];
      if (typeof value === 'string') {
        arr.push(new Attribute(type, value));
      } else {
        // array
        for (var j = 0; j < value.length; j++) {
          var elementValue = value[j];
          arr.push(new Attribute(type, elementValue));
        }
      }
    }
    return arr;
  };

  SignedMessage._getIterable = function _getIterable(authorOrRecipient) {
    var _ref;

    return _ref = {}, _ref[Symbol.iterator] = /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
      var keys, i, type, value, j, elementValue;
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              keys = Object.keys(authorOrRecipient);
              i = 0;

            case 2:
              if (!(i < keys.length)) {
                _context.next = 21;
                break;
              }

              type = keys[i];
              value = authorOrRecipient[keys[i]];

              if (!(typeof value === 'string')) {
                _context.next = 10;
                break;
              }

              _context.next = 8;
              return new Attribute(type, value);

            case 8:
              _context.next = 18;
              break;

            case 10:
              j = 0;

            case 11:
              if (!(j < value.length)) {
                _context.next = 18;
                break;
              }

              elementValue = value[j];
              _context.next = 15;
              return new Attribute(type, elementValue);

            case 15:
              j++;
              _context.next = 11;
              break;

            case 18:
              i++;
              _context.next = 2;
              break;

            case 21:
            case 'end':
              return _context.stop();
          }
        }
      }, _callee, this);
    }), _ref;
  };

  /**
  * @returns {object} Javascript iterator over author attributes
  */


  SignedMessage.prototype.getAuthorIterable = function getAuthorIterable() {
    return SignedMessage._getIterable(this.signedData.author);
  };

  /**
  * @returns {object} Javascript iterator over recipient attributes
  */


  SignedMessage.prototype.getRecipientIterable = function getRecipientIterable() {
    return SignedMessage._getIterable(this.signedData.recipient);
  };

  /**
  * @returns {array} Array containing author attributes
  */


  SignedMessage.prototype.getAuthorArray = function getAuthorArray() {
    return SignedMessage._getArray(this.signedData.author);
  };

  /**
  * @returns {array} Array containing recipient attributes
  */


  SignedMessage.prototype.getRecipientArray = function getRecipientArray() {
    return this.signedData.recipient ? SignedMessage._getArray(this.signedData.recipient) : [];
  };

  /**
  * @returns {string} SignedMessage signer keyID, i.e. base64 hash of public key
  */


  SignedMessage.prototype.getSignerKeyID = function getSignerKeyID() {
    return this.pubKey; // hack until gun supports keyID lookups
    //return util.getHash(this.pubKey);
  };

  SignedMessage.prototype._validate = function _validate() {
    if (!this.signedData) {
      throw new ValidationError(errorMsg + ' Missing signedData');
    }
    if (typeof this.signedData !== 'object') {
      throw new ValidationError(errorMsg + ' signedData must be an object');
    }
    var d = this.signedData;

    if (!d.type) {
      throw new ValidationError(errorMsg + ' Missing type definition');
    }
    if (!d.author) {
      throw new ValidationError(errorMsg + ' Missing author');
    }
    if (typeof d.author !== 'object') {
      throw new ValidationError(errorMsg + ' Author must be object');
    }
    if (Array.isArray(d.author)) {
      throw new ValidationError(errorMsg + ' Author must not be an array');
    }
    if (Object.keys(d.author).length === 0) {
      throw new ValidationError(errorMsg + ' Author empty');
    }
    if (this.pubKey) {
      this.signerKeyHash = this.getSignerKeyID();
    }
    for (var attr in d.author) {
      var t = _typeof(d.author[attr]);
      if (t !== 'string') {
        if (Array.isArray(d.author[attr])) {
          for (var i = 0; i < d.author[attr].length; i++) {
            if (typeof d.author[attr][i] !== 'string') {
              throw new ValidationError(errorMsg + ' Author attribute must be string, got ' + attr + ': [' + d.author[attr][i] + ']');
            }
            if (d.author[attr][i].length === 0) {
              throw new ValidationError(errorMsg + ' author ' + attr + ' in array[' + i + '] is empty');
            }
          }
        } else {
          throw new ValidationError(errorMsg + ' Author attribute must be string or array, got ' + attr + ': ' + d.author[attr]);
        }
      }
      if (attr === 'keyID') {
        if (t !== 'string') {
          throw new ValidationError(errorMsg + ' Author keyID must be string, got ' + t);
        }
        if (this.signerKeyHash && d.author[attr] !== this.signerKeyHash) {
          throw new ValidationError(errorMsg + ' If message has a keyID author, it must be signed by the same key');
        }
      }
    }
    if (d.recipient) {
      if (typeof d.recipient !== 'object') {
        throw new ValidationError(errorMsg + ' Recipient must be object');
      }
      if (Array.isArray(d.recipient)) {
        throw new ValidationError(errorMsg + ' Recipient must not be an array');
      }
      if (Object.keys(d.recipient).length === 0) {
        throw new ValidationError(errorMsg + ' Recipient empty');
      }
      for (var _attr in d.recipient) {
        var _t = _typeof(d.recipient[_attr]);
        if (_t !== 'string') {
          if (Array.isArray(d.recipient[_attr])) {
            for (var _i = 0; _i < d.recipient[_attr].length; _i++) {
              if (typeof d.recipient[_attr][_i] !== 'string') {
                throw new ValidationError(errorMsg + ' Recipient attribute must be string, got ' + _attr + ': [' + d.recipient[_attr][_i] + ']');
              }
              if (d.recipient[_attr][_i].length === 0) {
                throw new ValidationError(errorMsg + ' recipient ' + _attr + ' in array[' + _i + '] is empty');
              }
            }
          } else {
            throw new ValidationError(errorMsg + ' Recipient attribute must be string or array, got ' + _attr + ': ' + d.recipient[_attr]);
          }
        }
      }
    }
    if (!(d.time || d.timestamp)) {
      throw new ValidationError(errorMsg + ' Missing time field');
    }

    if (!Date.parse(d.time || d.timestamp)) {
      throw new ValidationError(errorMsg + ' Invalid time field');
    }

    if (d.type === 'rating') {
      if (isNaN(d.rating)) {
        throw new ValidationError(errorMsg + ' Invalid rating');
      }
      if (isNaN(d.maxRating)) {
        throw new ValidationError(errorMsg + ' Invalid maxRating');
      }
      if (isNaN(d.minRating)) {
        throw new ValidationError(errorMsg + ' Invalid minRating');
      }
      if (d.rating > d.maxRating) {
        throw new ValidationError(errorMsg + ' Rating is above maxRating');
      }
      if (d.rating < d.minRating) {
        throw new ValidationError(errorMsg + ' Rating is below minRating');
      }
      if (typeof d.context !== 'string' || !d.context.length) {
        throw new ValidationError(errorMsg + ' Rating messages must have a context field');
      }
    }

    if (d.type === 'verification' || d.type === 'unverification') {
      if (d.recipient.length < 2) {
        throw new ValidationError(errorMsg + ' At least 2 recipient attributes are needed for a connection / disconnection. Got: ' + d.recipient);
      }
    }

    return true;
  };

  /**
  * @returns {boolean} true if message has a positive rating
  */


  SignedMessage.prototype.isPositive = function isPositive() {
    return this.signedData.type === 'rating' && this.signedData.rating > (this.signedData.maxRating + this.signedData.minRating) / 2;
  };

  /**
  * @returns {boolean} true if message has a negative rating
  */


  SignedMessage.prototype.isNegative = function isNegative() {
    return this.signedData.type === 'rating' && this.signedData.rating < (this.signedData.maxRating + this.signedData.minRating) / 2;
  };

  /**
  * @returns {boolean} true if message has a neutral rating
  */


  SignedMessage.prototype.isNeutral = function isNeutral() {
    return this.signedData.type === 'rating' && this.signedData.rating === (this.signedData.maxRating + this.signedData.minRating) / 2;
  };

  /**
  * @param {Object} key Gun.SEA keypair to sign the message with
  */


  SignedMessage.prototype.sign = async function sign(key) {
    this.sig = await Key.sign(this.signedData, key);
    this.pubKey = key.pub;
    await this.getHash();
    return true;
  };

  /**
  * Create an iris message. SignedMessage time is automatically set. If signingKey is specified and author omitted, signingKey will be used as author.
  * @param {Object} signedData message data object including author, recipient and other possible attributes
  * @param {Object} signingKey optionally, you can set the key to sign the message with
  * @returns {Promise<SignedMessage>}  message
  */


  SignedMessage.create = async function create(signedData, signingKey) {
    if (!signedData.author && signingKey) {
      signedData.author = { keyID: Key.getId(signingKey) };
    }
    signedData.time = signedData.time || new Date().toISOString();
    var m = new SignedMessage({ signedData: signedData });
    if (signingKey) {
      await m.sign(signingKey);
    }
    return m;
  };

  /**
  * Create an  verification message. SignedMessage signedData's type and time are automatically set. Recipient must be set. If signingKey is specified and author omitted, signingKey will be used as author.
  * @returns {Promise<Object>} message object promise
  */


  SignedMessage.createVerification = function createVerification(signedData, signingKey) {
    signedData.type = 'verification';
    return SignedMessage.create(signedData, signingKey);
  };

  /**
  * Create an  rating message. SignedMessage signedData's type, maxRating, minRating, time and context are set automatically. Recipient and rating must be set. If signingKey is specified and author omitted, signingKey will be used as author.
  * @returns {Promise<Object>} message object promise
  */


  SignedMessage.createRating = function createRating(signedData, signingKey) {
    signedData.type = 'rating';
    signedData.context = signedData.context || 'iris';
    signedData.maxRating = signedData.maxRating || 10;
    signedData.minRating = signedData.minRating || -10;
    return SignedMessage.create(signedData, signingKey);
  };

  /**
  * @param {Index} index index to look up the message author from
  * @returns {Contact} message author identity
  */


  SignedMessage.prototype.getAuthor = function getAuthor(index) {
    for (var _iterator = this.getAuthorIterable(), _isArray = Array.isArray(_iterator), _i2 = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref2;

      if (_isArray) {
        if (_i2 >= _iterator.length) break;
        _ref2 = _iterator[_i2++];
      } else {
        _i2 = _iterator.next();
        if (_i2.done) break;
        _ref2 = _i2.value;
      }

      var a = _ref2;

      if (a.isUniqueType()) {
        return index.getContacts(a);
      }
    }
  };

  /**
  * @param {Index} index index to look up the message recipient from
  * @returns {Contact} message recipient identity or undefined
  */


  SignedMessage.prototype.getRecipient = function getRecipient(index) {
    if (!this.signedData.recipient) {
      return undefined;
    }
    for (var _iterator2 = this.getRecipientIterable(), _isArray2 = Array.isArray(_iterator2), _i3 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
      var _ref3;

      if (_isArray2) {
        if (_i3 >= _iterator2.length) break;
        _ref3 = _iterator2[_i3++];
      } else {
        _i3 = _iterator2.next();
        if (_i3.done) break;
        _ref3 = _i3.value;
      }

      var a = _ref3;

      if (a.isUniqueType()) {
        return index.getContacts(a);
      }
    }
  };

  /**
  * @returns {string} base64 sha256 hash of message
  */


  SignedMessage.prototype.getHash = async function getHash() {
    if (this.sig && !this.hash) {
      this.hash = await util.getHash(this.sig);
    }
    return this.hash;
  };

  SignedMessage.prototype.getId = function getId() {
    return this.getHash();
  };

  SignedMessage.fromSig = async function fromSig(obj) {
    if (!obj.sig) {
      throw new Error('Missing signature in object:', obj);
    }
    if (!obj.pubKey) {
      throw new Error('Missing pubKey in object:');
    }
    var signedData = await Key.verify(obj.sig, obj.pubKey);
    var o = { signedData: signedData, sig: obj.sig, pubKey: obj.pubKey };
    return new SignedMessage(o);
  };

  /**
  * @return {boolean} true if message signature is valid. Otherwise throws ValidationError.
  */


  SignedMessage.prototype.verify = async function verify() {
    if (!this.pubKey) {
      throw new ValidationError(errorMsg + ' SignedMessage has no .pubKey');
    }
    if (!this.sig) {
      throw new ValidationError(errorMsg + ' SignedMessage has no .sig');
    }
    this.signedData = await Key.verify(this.sig, this.pubKey);
    if (!this.signedData) {
      throw new ValidationError(errorMsg + ' Invalid signature');
    }
    if (this.hash) {
      if (this.hash !== (await util.getHash(this.sig))) {
        throw new ValidationError(errorMsg + ' Invalid message hash');
      }
    } else {
      this.getHash();
    }
    return true;
  };

  /**
  * @returns {string}
  */


  SignedMessage.prototype.serialize = function serialize() {
    return { sig: this.sig, pubKey: this.pubKey };
  };

  SignedMessage.prototype.toString = function toString() {
    return JSON.stringify(this.serialize());
  };

  /**
  * @returns {Promise<SignedMessage>}
  */


  SignedMessage.deserialize = async function deserialize(s) {
    return SignedMessage.fromSig(s);
  };

  SignedMessage.fromString = async function fromString(s) {
    return SignedMessage.fromSig(JSON.parse(s));
  };

  /**
  *
  */


  SignedMessage.setReaction = async function setReaction(gun, msg, reaction) {
    var hash = await msg.getHash();
    gun.get('reactions').get(hash).put(reaction);
    gun.get('reactions').get(hash).put(reaction);
    gun.get('messagesByHash').get(hash).get('reactions').get(this.rootContact.value).put(reaction);
    gun.get('messagesByHash').get(hash).get('reactions').get(this.rootContact.value).put(reaction);
  };

  return SignedMessage;
}();

export default SignedMessage;