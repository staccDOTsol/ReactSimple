/* Communicates over the ipfs pubsub topic "gundb".

In this example, ipfs is initialized with webrtc signalling servers for peer finding:

Ipfs.create({
  config: {
    Addresses: {
      Swarm: [
          '/dns4/wrtc-star1.par.dwebops.pub/tcp/443/wss/p2p-webrtc-star',
          '/dns4/wrtc-star2.sjc.dwebops.pub/tcp/443/wss/p2p-webrtc-star'
      ]
    },
  }
}).then(ipfs => {
  const gun = window.gun = new Gun({ipfs});
});

 */
var Gun = (typeof window !== "undefined")? window.Gun : require('../gun');

Gun.on('create', async function(root){
	this.to.next(root);
	var opt = root.opt;
  if(!opt.ipfs){ return }
  if (!opt.ipfs.pubsub) {
    console.log('ipfs.pubsub needs to be enabled');
    return;
  }
  var ipfs = opt.ipfs;

  var myId = (await ipfs.id()).id;

  console.log('loaded gun ipfs plugin');

  let batch = [];

  function send() {
    if (batch.length) {
      var encoded = new TextEncoder().encode(JSON.stringify(batch.length === 1 ? batch[0] : batch));
      batch = [];
      ipfs.pubsub.publish('gundb', encoded).then(() => {
        setTimeout(send, 1000);
      });
    } else {
      setTimeout(send, 1000);
    }
  }
  send();

  root.on('out', function(msg) {
    this.to.next(msg);
    if (msg.put || msg.get) { // only relay put and get
      batch.push(msg);
    }
  });

  function receive(msg) {
    try {
      if (msg.from === myId) {
        return;
      }
      if (msg.data) {
        msg = new TextDecoder().decode(msg.data);
        msg = JSON.parse(msg);
      }
      if(msg instanceof Array){
        var i = 0, m;
        while(m = msg[i++]){
          receive(m); // wire not peer!
        }
        return;
      }
      if (msg.put || msg.get) { // only relay put and get
        root.on('in', msg);
      }
    }catch(e){console.error('ipfs receive error', e)}
  };

  ipfs.pubsub.subscribe('gundb', receive);
});
