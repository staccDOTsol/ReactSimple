import enzyme from 'enzyme';
import { h } from 'preact';
import MountRenderer from './MountRenderer.js';
import ShallowRenderer from './ShallowRenderer.js';
import StringRenderer from './StringRenderer.js';
import { rstNodeFromElement } from './preact10-rst.js';
import wrapWithWrappingComponent from './wrapWithWrappingComponent.js';
import RootFinder from './RootFinder.js';
export const { EnzymeAdapter } = enzyme;
export default class Adapter extends EnzymeAdapter {
    constructor() {
        super();
        // This function is only called during shallow rendering
        this.wrapWithWrappingComponent = (node, 
        /**
         * Tip:
         * The use of `wrappingComponent` and `wrappingComponentProps` is discouraged.
         * Using those props complicates a potential future migration to a different testing library.
         * Instead, wrap a component like this:
         * ```
         * shallow(<Wrapper><Component/></Wrapper>).dive()
         * ```
         */
        options) => {
            return {
                RootFinder: RootFinder,
                node: wrapWithWrappingComponent(this.createElement, node, options),
            };
        };
        this.options = {
            // Prevent Enzyme's shallow renderer from manually invoking lifecycle
            // methods after a render. This manual invocation is needed for React
            // but not for the Preact adapter because we re-use the normal rendering
            // logic.
            lifecycles: {
                componentDidUpdate: {
                    onSetState: false,
                },
            },
        };
        // Work around a bug in Enzyme where `ShallowWrapper.getElements` calls
        // the `nodeToElement` method with undefined `this`.
        this.nodeToElement = this.nodeToElement.bind(this);
    }
    createRenderer(options) {
        switch (options.mode) {
            case 'mount':
                // The `attachTo` option is only supported for DOM rendering, for
                // consistency with React, even though the Preact adapter could easily
                // support it for shallow rendering.
                return new MountRenderer({ ...options, container: options.attachTo });
            case 'shallow':
                return new ShallowRenderer();
            case 'string':
                return new StringRenderer();
            default:
                throw new Error(`"${options.mode}" rendering is not supported`);
        }
    }
    nodeToElement(node) {
        if (typeof node === 'string') {
            return node;
        }
        const childElements = node.rendered.map(n => this.nodeToElement(n));
        return h(node.type, node.props, ...childElements);
    }
    nodeToHostNode(node) {
        if (typeof node === 'string') {
            // Returning `null` here causes `wrapper.text()` to return nothing for a
            // wrapper around a `Text` node. That's not intuitive perhaps, but it
            // matches the React adapters' behaviour.
            return null;
        }
        if (node.nodeType === 'host') {
            return node.instance;
        }
        else if (node.rendered.length > 0) {
            return this.nodeToHostNode(node.rendered[0]);
        }
        else {
            return null;
        }
    }
    isValidElement(el) {
        if (el == null) {
            return false;
        }
        if (typeof el.type !== 'string' &&
            typeof el.type !== 'function' &&
            el.type !== null) {
            return false;
        }
        if (typeof el.props !== 'object' || el.props == null) {
            return false;
        }
        return true;
    }
    createElement(type, props, ...children) {
        return h(type, props, ...children);
    }
    elementToNode(el) {
        return rstNodeFromElement(el);
    }
}
